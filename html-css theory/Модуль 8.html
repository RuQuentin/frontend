<!DOCTYPE html>
<!-- saved from url=(0041)http://fecore.net.ua/theory/module-8.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,maximum-scale=1,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Модуль 8</title><link rel="stylesheet" href="./Модуль 8_files/styles.min.css"><script async="" src="./Модуль 8_files/ei.js.Без названия"></script><script async="" src="./Модуль 8_files/prism.js.Без названия"></script></head><body><div class="wrapper"><article><header><h1>Модуль 8 - Теория</h1><!-- ===== page-navigator =====  --><section class="table-of-contents" id="main-nav"><h2>Содержание</h2><ol class="page-nav"><li><a href="http://fecore.net.ua/theory/module-8.html#entry">Введение в Responsive веб дизайн</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#new-ways">Новые подходы к верстке</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#meta-tag">Responsive meta tag</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#devtools">Chrome DevTools</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#philosophy">Философия Responsive веб дизайна</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#rules">Правила responsive верстки</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#mf-df">Mobile-first vs Desktop-first</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#queries">Медиазапросы</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#images">Отзывчивые изображения</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#mobile-css">Mobile-first css</a></li><li><a href="http://fecore.net.ua/theory/module-8.html#resources">Дополнительные материалы</a></li></ol></section><!-- ====== end page-navigator =====  --></header><!-- SECTION --><section id="entry"><h2>Введение в Responsive веб дизайн</h2><p>Раньше сайты были с фиксированной версткой. Если сайт был в ширину 800 пикселей — он так и оставался 800 пикселей, на каком мониторе его ни открывай, большом или крохотном. Такой подход полностью устарел вместе с табличной версткой.</p><p>Потом сайты стали «резиновыми». Если мы меняли размер окна браузера — элементы сжимались или растягивались. Открывали на большом мониторе или на маленьком, или на смартфоне — везде сайт выглядел симпатично, менялся только масштаб. Это было удобно пользователю и смотрелось красиво. Но и такой подход тоже устарел.</p><p>Больше половины трафика в интернете приходится на мобильные телефоны и планшеты. Поэтому создание отзывчивых веб-сайтов сегодня является обязательным для разработчика интерфейсов.</p></section><!-- SECTION --><section id="new-ways"><h2>Новые подходы к верстке</h2><p>В современном вебе используются новые подходы при создании веб сайтов. Они сочетают в себе элементы «резиновой» верстки и новые, современные приемы, такие как адаптивность и отзывчивость. Термины «адаптивный сайт» и «отзывчивый сайт» (adaptive и responsive) кардинально отличаются. Давайте разберемся, что это такое.</p><img src="./Модуль 8_files/responsive-vs-adaptive.gif" alt=""><!-- subsection --><h3>Отзывчивый сайт</h3><p>Сайт, который имеет несколько вариантов отображения, переходы между ними плавные, как на «резине». Меняете размер окна — кнопки медленно меняются в размерах, блоки плавно ужимаются, а когда наступает контрольная точка — сайт меняет расположение блоков под планшет или под смартфон.</p><div class="note"><p><strong>Особенность:</strong> плавные переходы между ключевыми вариантами отображения. Если сайт оптимизировался под iPad, то он будет также хорошо смотреться и на Galaxy Tab, и на любом устройстве.</p></div><!-- subsection --><h3>Адаптивный сайт</h3><p>Сайт, который на мониторе отображается одним образом, на планшете иначе, а на смартфоне — снова по-другому. Меняется расположение блоков, размеры кнопок и полей, текстов. Зачем? Чтобы пользователю было комфортнее пользоваться сайтом: в кнопку легче попадать пальцем, если она крупная, текст в метро легче читать, если он 20 пунктов, а не 14.</p><div class="note"><p><strong>Особенность:</strong> сайт имеет всего несколько «вариантов отображения» в зависимости от ширины экрана или типа устройства. То есть на всех планшетах будет один сайт, без учета, что у них разные по размеру дисплеи. Аналогично — если менять размер окна браузера, то сайт будет меняться «рывками», а не так, как мы привыкли видеть на «резиновых» сайтах.</p></div><!-- subsection --><h3>Что лучше?</h3><p>Нет однозначного ответа. Отзывчивая верстка определенно дороже, так как делать ее дольше. Иногда достаточно просто «резинового» сайта. Иногда — бизнес-задачи лучше выполнит отдельная мобильная версия. Или вообще приложение вместо сайта. Все больше и больше разработчики склоняются к «отзывчивым» сайтам. Именно этот подход мы и будем рассматривать более подробно.</p></section><!-- SECTION --><section id="meta-tag"><h2>Responsive meta tag</h2><p>Страницы, адаптированные для просмотра на разных устройствах, должны содержать в разделе head мета-тег viewport. Он сообщает браузеру, каким образом нужно контролировать размеры и масштаб страницы. Добавим в head, кроме всех остальных тегов, еще мета-тег вьюпорта.</p><p>Таким образом, ширина окна просмотра будет адаптироваться к ширине экрана устройства width=device-width, обеспечивая соотношение 1:1 между пикселями CSS и аппаратными пикселями устройства initial-scale=1.0</p><pre class=" language-markup"><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span></code></pre></section><!-- SECTION --><section id="devtools"><h2>Chrome DevTools для работы с мобильной версткой</h2><p>Если перейти в режим DevTools и нажать на иконку <code class="accent">#1</code> , мы перейдем в responsive режим, появятся дополнительные инструменты для работы с responsive версткой. Чтобы выйти из этого режима, нажмите на иконку <code class="accent">#1</code> еще раз.</p><p>Теперь вы можете изменять ширину окна браузера, используя контролы <code class="accent">#2</code> , простым растягиванием, как будто вы растягиваете или сжимаете окно браузера.</p><p>В группе <code class="accent">#3</code> указаны текущие размеры ширины\высоты, а так же некоторые другие опции которые пока что нам не интересны. Немного ниже группы <code class="accent">#3</code> находятся контролы быстрого изменения ширины экрана по стандартным точкам перелома. О них позже.</p><img src="./Модуль 8_files/responsive-devtools.jpg" alt=""></section><!-- SECTION --><section id="philosophy"><h2>Философия Responsive веб дизайна</h2><p>Так как веб страницу сейчас можно открыть на множестве устройств и экранов, было необходимо решение проблем отображения контента. Философия отзывчивого веб дизайна построена на нескольких подходах и приемах при верстке. Давайте рассмотрим их подробнее.</p><!-- subsection --><h3>Относительные единицы</h3><p>Сайт можно открыть на ПК, мобильном телефоне и т.д., при чем элементы интерфейса должны соблюдать пропорции, задуманые дизайнером. Плотность пикселей также может меняться, поэтому нам нужны единицы, которые гибки и работают повсюду. Вот где нам подходят относительные единицы, такие как проценты. Таким образом, если задать блоку ширину 50%, он всегда будет занимать половину экрана. Так же на помощь приходят rem и em для задания ширин элементов интерфейса и отступов в относительных единицах.</p></section><!-- SECTION --><section id="rules"><h2>Правила responsive верстки</h2><p>В этом разделе мы познакомимся с методами, которые применяются при responsive верстке.</p><!-- subsection --><h3>width в %</h3><p>Итак, ширины блоков мы задаем не в px, а в процентах. Таким образом, когда макет сжимается на крошечном мобильном устройстве или растягивается через огромный экран, все элементы в макете будут изменять их ширину по отношению друг к другу.</p><p>Чтобы рассчитать пропорции для каждого элемента страницы, вы должны разделить целевой элемент на его контекст. В настоящее время лучший способ сделать это - сначала открыть макет в редакторе, таком как Photoshop. Благодаря высокому качеству макета, вы можете измерить элемент страницы и разделить его на всю ширину страницы.</p><p>Например, если ваш макет по ширине равен 960 пикселям, тогда это будет ваше «контейнерное» значение. Предположим, что наш целевой элемент - это какое-то произвольное значение, например, 300 пикселей в ширину. Если умножить результат на 100, мы получим процентное значение 31,25%, которое мы можем применить к целевому элементу.</p><img src="./Модуль 8_files/percent-width.jpg" alt=""><div class="warn"><p>Если результирующее значение процентов получилось не целым, и вы получаете некоторое значение с плавающей точкой, не округляйте значение! Окончательный внешний вид страницы выиграет от кажущейся чрезмерной математической точности.</p></div><!-- subsection --><h3>min и max width</h3><p>Важной частью отзывчивого дизайна является использование минимальных/максимальных ширин контейнеров в пикселях (или rem/em) и ширин в % для контента внутри контейнеров. При responsive верстке не может быть фиксированных ширин в пикселях даже у оберток(дальше контейнер), может быть только максимальная/минимальная ширина. Это сделано для того чтобы контейнер растягивался на 100% текущей ширины окна браузера, но не растягивался больше чем максимальная ширина указанная в макете.</p><!-- subsection --><h3>Пример</h3><p>Напишем следующий HTML - контейнер для трех колонок, левого и правого сайдбаров и контентной части. Зададим контейнеру display flex, и высоту 200px для наглядности. К примеру, на макете content это обертка шириной 960px. Обратите внимание на max-width: 960px.</p><p>А теперь, к примеру, на макете мы отмеряли ширины left и right sidebar по 240px . Вместо того чтобы задать им ширину 240px, мы считаем ширину в процентах от общей ширины container.</p><p class="accent">width = 240 / 960 = 0.25</p><p>Помним, что для получения процентов нужно умножать результат на 100.</p><p class="accent">width в % = 0.25 * 100 = 25%</p><p>Так же мы можем замерить ширину content и высчитать ее. Допустим у нас получится 50% для articles, оставшееся свободное пространство.</p><p>Получилась классическая «резиновая» верстка. Теперь если вы будете растягивать или сужать окно браузера, верстка будет подстраиваться под текущую ширину экрана. Ширина sidebar'ов всегда будет равна по 25% от общей ширины, articles 50%.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_ZJexNx" src="./Модуль 8_files/ZJexNx.html" scrolling="no" frameborder="0" height="269" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-8-responsive-width" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>margin</h3><p>Горизонтальный margin для блоков задается в процентах. Если бы по макету у нас были зазоры между articles и сайдбарами, и допустим articles был бы 46% шириной. Тогда ширины блоков выглядели бы следующим образом.</p><ul><li>articles - 46%</li><li>left-sidebar - 25%</li><li>right-sidebar - 25%</li><li>articles левый и правый margin был бы по 2%</li></ul><p>Итого занято 100% ширины content. Конечно, если мы используем Flexbox, то достаточно задать justify-content: space-between, явно задавать margin не надо. Зазоры между колонками все равно будут по 2%.</p><div class="note"><p>Не забывайте о том, что горизонтальный margin у блоков задается в % от ширины родителя. В то же время горизонтальный margin у элементов блока задается в rem. К примеру, блок статей. Если горизонтальный margin между статьями задается в %, то margin элементов внутри статьи задается в rem. Это не абсолютное правило, скорее хорошая практика.</p></div><!-- subsection --><h3>padding</h3><p>В отличие от margin, в 99% случаев при responsive верстке, вертикальный и горизонтальный padding задается в rem\em.</p><h3>Подведем итоги</h3><p>Это отличный подход к созданию отзывчивой веб страницы, но не все так просто. Когда ширина браузера становится слишком узкой, страница может начать сильно искажаться. Например, сложный трехколоночный макет не очень хорошо работает на небольшом мобильном телефоне. К счастью, отзывчивый дизайн позаботился об этой проблеме, используя медиа-запросы, о них позже.</p></section><!-- SECTION --><section id="mf-df"><h2>Mobile-first vs Desktop-first responsive design</h2><p>Перед тем как разбираться с медиазапросами, давайте кратко поговорим о различиях между mobile-first и desktop-first подходами при responsive верстке.</p><!-- subsection --><h3>Desktop-first</h3><p>Ориентирован на широкие экраны, - это подход, при котором стили применяются сначала к настольным устройствам. Расширенные стили и переопределения для меньших экранов затем добавляются в таблицу стилей через медизапросы.</p><!-- subsection --><h3>Mobile-first</h3><p>Ориентирован на узкие экраны, - это подход, при котором стили применяются сначала к мобильным устройствам. Расширенные стили и другие переопределения для больших экранов затем добавляются в таблицу стилей через медизапросы.</p><div class="note"><p>По многим причинам, в том числе потому, что более 50% интернет-трафика приходится на мобильные телефоны, сейчас в веб разработке используют mobile-first подход.</p></div></section><!-- SECTION --><section id="queries"><h2>Медиазапросы (Media Queries)</h2><p><strong>Медиазапросы</strong> — это модуль CSS3, который позволяет создавать отзывчивые веб-сайты, используя различные правила стилей для разных устройств или типов носителей. В зависимости от этих правил содержимое отображается в соответствии с различными условиями, например размером экрана, окна браузера или самого устройства, а также ориентацией и разрешением устройства.</p><p>В общем случае медиа-запрос состоит из ключевого слова, описывающего тип устройства (необязательный параметр) и выражения, проверяющего характеристики данного устройства. Из всех характеристик чаще всего проверяется ширина устройства width. Медиа-запрос является логическим выражением, которое возвращает истину или ложь.</p><!-- subsection --><h3>Способы добавления медиазапросов</h3><p>Существует несколько способов добавления медиазапросов к странице, появлялись они последовательно, с развитием отзывчивого веб-дизайна. Отличаются лишь в имплементации, результат работы будет одинаков.</p><!-- subsection --><h4>В HTML файле</h4><p>Создается файл стилей и наполняется css правилами. После чего подключается к странице, используя тег link, к которому добавляется атрибут media. Отметим, что сам файл стилей будет загружен вместе со страницей, не зависимо от ширины экрана устройства. Но стили из него будут применены только при выполнении условий media.</p><!-- subsection --><h4>Внутри таблицы стилей</h4><p>Создается файл стилей. Внутри него, используя специальную конструкцию @media, описываются стили для определенных ширин экрана. В примере ниже при ширине экрана 768px и выше цвет левой колонки изменится.</p><p>В современной разработке значительно чаще используется этот метод. Мы прописываем стили элементам интерфейса под определенные медиаправила, и они применяются в зависимости от условий.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_MvpXZK" src="./Модуль 8_files/MvpXZK.html" scrolling="no" frameborder="0" height="268" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-8-media-basics" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p><strong>@media (rules)</strong> - используется для применения стилей на определенных носителях, размерах экрана и т.д. Это позволяет нам указать различные варианты дизайна в зависимости от размера экрана. Затем страницу можно оптимизировать и показывать совершенно по-разному для мобильных телефонов, планшетов и разных размеров окон браузера.</p></div><!-- subsection --><h3>min-width vs max-width</h3><p>Давайте разберемся с min-width и max-width в rules у медиа-запроса.</p><p><code>@media (min-width: 500px)</code> - говорит о том, что стили, которые указаны внутри этого медиа-правила, будут применены при минимальной ширине экрана 500px и шире.</p><p><code>@media (max-width: 500px)</code> - говорит о том, что стили, которые указаны внутри этого медиа-правила, будут применены от нуля до максимальной ширины экрана в 500px.</p><!-- subsection --><h3>Логические операторы</h3><p>Логичным будет вопрос, а что делать, если я хочу чтобы какое-то css-правило применилось только в диапазоне, к примеру, от 400px до 800px? Или наоборот, применялось всегда кроме диапазона 400px-800px? Для этого существуют логические операторы. Мы рассмотрим самые распространенные.</p><!-- subsection --><h4>Операторы and и not</h4><ul><li><code>and</code> - связывает между собой разные условия. Код ниже сделает так, что левая колонка будет окрашиваться в желтый цвет в диапазоне 400px - 800px.</li><li><code>not</code> - позволяет сработать медиазапросу в противоположном случае. Ключевое слово not добавляется в начало медиазапроса и применяется ко всему запросу целиком.</li></ul><div class="cp_embed_wrapper"><iframe id="cp_embed_OjpwLG" src="./Модуль 8_files/OjpwLG.html" scrolling="no" frameborder="0" height="269" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-8-media-operators" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Типы устройств</h3><p>Что это за screen? Это один из типов устройств, всего их 4. Этот параметр не является обязательным и служит для более специфичного применения медиаправила.</p><table><tbody><tr><th>Тип</th><th>Описание</th></tr><tr><td>all</td><td>Подходит для всех типов устройств</td></tr><tr><td>print</td><td>Предназначен для страничных материалов и документов, просматриваемых на экране в режиме предварительного просмотра печати.</td></tr><tr><td>screen</td><td>Предназначен, в первую очередь для экранов цветных компьютерных мониторов.</td></tr><tr><td>speech</td><td>Предназначен для синтезаторов речи.</td></tr></tbody></table><!-- subsection --><h3>Характеристики носителя</h3><p>К характеристикам медианосителя относятся проверяемые параметры устройства. Значения, которые используются при задании характеристик, являются контрольными точками. Такие как max-device-aspect-ratio, max-device-width, min-width, min-resolution и многие другие.</p><!-- subsection --><h3>Device Orientation</h3><p>Если вам необходимо применить CSS в зависимости от ориентации браузера, вам помогут следующие правила. Это может быть особенно полезно для мобильных устройств.</p><table><tbody><tr><th>ориентация</th><th>правило</th></tr><tr><td>Горизонтальная (landscape)</td><td>@media screen and (orientation: landscape) {...}</td></tr><tr><td>Вертикальная (portrait)</td><td>@media screen and (orientation: portrait) {...}</td></tr></tbody></table><!-- subsection --><h3>Pixel Ratio</h3><p>Важно иметь в виду, что пиксель CSS не должен быть таким же, как физический пиксель. Хотя экран может физически иметь ширину 720 пикселей, браузер может фактически применять CSS, предполагая, что он имеет ширину 480 пикселей. Это сделано затем, чтобы стандартная веб-страница с большей вероятностью подошла под экран. В этом примере соотношение пикселей равно 1,5:1 - на каждый пиксель CSS есть 1½ физических пикселя. Стандартный настольный монитор будет иметь соотношение пикселей 1:1 - один пиксель CSS к каждому физическому пикселю.</p><p>Это media будет применено к экранам с соотношением пикселей 2:1. Также можно использовать min-device-pixel-ratio и max-device-pixel-ratio.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_yoMqoM" src="./Модуль 8_files/yoMqoM.html" scrolling="no" frameborder="0" height="287" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-8-pixel-ratio" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Несколько медиаправил</h3><p>Вы можете применить сколько угодно правил @media, поэтому у вас может быть несколько разных дизайнов (макетов), зависящих от размера экрана.</p><p>Данные медиаправила будут изменять фон body в зависимости от ширины экрана.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_ZJejja" src="./Модуль 8_files/ZJejja.html" scrolling="no" frameborder="0" height="235" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-8-multiple-media" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p class="accent">Итак, алгоритм записи медиаправила:</p><ul><li>Указываем @media и выражение проверки ширины экрана устройства</li><li>Внутри media указываем css-правило для селектора</li><li>Внутри css-правила указываем css-свойства и их значения, которые мы хотим применить при этом media</li></ul><div class="note"><ul><li>Мы можем применить сколько угодно media в файле стилей, главное следить за выражениями проверки ширины экрана. Чтобы не было конфликтов.</li><li>Внутри каждого media нет ограничения на количество css-правил, мы можем написать сколько угодно css правил для разных селекторов внутри одного media.</li><li>css-правила наследуются. Это значит, правила написаные при <code>min-width: 480px</code>, будут применяться и при <code>min-width: 768px</code>.</li></ul></div><!-- subsection --><h3>Как узнать какие прописывать медиаправила?</h3><p>При составлении медиазапросов нужно ориентироваться на так называемые переломные (контрольные) точки дизайна, т.е. такие значения ширины области просмотра, в которых дизайн сайта существенно меняется, например, изменяется положение элементов интерфейса. Для верстальщика это те точки, макеты для которых ему предоставили.</p><p>Под каждую контрольную точку рисуется отдельный макет. Между контрольными точками, верстка должна быть «резиновой». Чтобы адаптировать дизайн сайта под разные устройства, необходимо задать разные стили для разных разрешений экранов, используя определённые контрольные точки.</p><!-- subsection --><h4>Распространенные переломные точки</h4><table><tbody><tr><th>ширина</th><th>устройство</th></tr><tr><td>320px</td><td>Мобильные телефоны с узким экраном</td></tr><tr><td>480px</td><td>Современные смартфоны среднего\высокого уровня</td></tr><tr><td>768px</td><td>Таблетки</td></tr><tr><td>960px</td><td>Таблетки с широким экраном</td></tr><tr><td>1200px</td><td>Ноутбуки</td></tr><tr><td>1440px</td><td>Десктопы</td></tr></tbody></table></section><!-- SECTION --><section id="images"><h2>Responsive images</h2><p><strong>Отзывчивые изображения</strong> - изображения, которые хорошо отображаются на устройствах с различными размерами и разрешениями экрана.</p><p>Представьте изображение 1200x600 пикселей. Оно отлично выглядит на широком экране. А что будет, когда мы откроем нашу страницу, скажем на телефоне или таблетке? Ответ - ничего хорошего, без дополнительной работы, изображение будет оставаться шириной 1200px и появится полоса прокрутки. А как насчет веса изображения, действительно нужна ли нам картинка 1200x600 для телефона с экраном 320px?</p><!-- subsection --><h3>max-width и height</h3><p>Самый простой способ создать отзывчивое изображение, это задать ему максимальную ширину в 100%. Если для свойства <code>max-width</code> установлено значение 100%, изображение будет уменьшаться, если необходимо, но никогда не растянется больше чем 100% своей оригинальной ширины.</p><p>Еще одним важным моментом является свойство <code>height</code>. Ему необходимо дать значение <code>auto</code>, для того чтобы изображение сохраняло пропорции при изменении своей ширины.</p><div class="note"><p>Не забывайте о том, что тег <code>img</code> строчный. Это значит что у него всегда будет зазор как у любого строчного элемента. Всегда необходимо делать <code>img</code> блочным.</p></div><figure><img src="./Модуль 8_files/reposnsive-image.png" alt=""><figcaption>Вот так будет работать отзывчивое изображение. Оно одно для всех устройств и просто подстраивается под текущую ширину экрана.</figcaption></figure><p>Рассмотрим пример, создадим контейнер для картинки, зададим ему min/max ширину. Картинке дадим responsive-свойства. Теперь картинка будет всегда красиво заливать контейнер, изменяя свою ширину в зависимости от ширины контейнера.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_NvpMrv" src="./Модуль 8_files/NvpMrv.html" scrolling="no" frameborder="0" height="365" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-8-responsive-image" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Разные изображения для разных устройств</h3><p>62% веса веба, это изображения. Большое изображение может быть идеальным на большом экране компьютера, но бесполезно на маленьком устройстве. Зачем загружать большое изображение, когда вы все равно должны его масштабировать? Чтобы уменьшить нагрузку, мы можем использовать тег <code>picture</code>.</p><figure><img src="./Модуль 8_files/picture.png" alt="picture tag illustration"><figcaption>Тег picture предлагает браузеру для загрузки набор изображений. Браузер выбирает какое подходит лучше всего под текущие характеристики устройства и загружает всего лишь одно из них, а не все.</figcaption></figure><p>Атрибуты <code>srcset</code>, <code>sizes</code> и тег <code>source</code> позволяют нам выделять несколько альтернативных источников и раздавать каждому устройству то изображение, которое лучше всего ему подходит.</p><ul><li><code>srcset</code> - определяет набор изображений, которые мы разрешаем браузеру выбирать, и размер каждого изображения. В него, через запятую, мы записываем пары значений - url картинки и ее ширину в пикселях (для srcset это w). Зачем говорить браузеру какая у картинки ширина? Это браузер, разве он не знает размеры картинки? Знает! Но только после того, как загрузит все изображения. Если же браузер знает информацию о размере картинок с самого начала, будет загружена только та картинка, которая сейчас нужна.</li><li><code>sizes</code> - определяет набор условий среды (например, ширины экрана) и указывает, какой размер изображения лучше всего выбрать, когда выполняются определенные условия мультимедиа.</li><li><code>source</code> - тег, используется в picture, имеет 2 атрибута, media и srcset, которые в паре определяют медиаправило и изображение, которое будет отображено при его выполнении.</li></ul><p>Прежде чем мы посмотрим примеры, вот несколько вещей, которые нужно иметь в виду:</p><ul><li><code>picture</code> требует <code>img</code> как своего последнего ребенка. Без <code>img</code> ничего не отображается. Это повышает доступность, поскольку есть только одно место для альтернативного текста, и оно отлично подходит для резервного содержимого в старых браузерах, которые не поддерживают <code>picture</code>.</li><li>Думайте о атрибутах <code>sizes</code> и <code>srcset</code> тега <code>picture</code>, как о переопределяющих атрибут <code>src</code> тега <code>img</code>. Старые браузеры просто будут использовать <code>img src</code>.</li><li>Список <code>srcset</code> и <code>sizes</code> - это подсказка для браузеров, а не указание. Например, устройство с отношением пикселей 1,5 может свободно использовать изображение 1x или 2x, в зависимости от того, что он знает о своих возможностях, сети и т. д.</li><li>Выражение <code>&lt;img sizes="(max-width: 30rem) 100vw ..."&gt;</code> говорит: если этот медиа-запрос истинен, показать изображение с шириной 100vw. Первый подходящий медиа-запрос "побеждает", поэтому порядок источников имеет значение.</li></ul><div class="cp_embed_wrapper"><iframe id="cp_embed_vJxjQg" src="./Модуль 8_files/vJxjQg.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-8-srcset-sizes-media" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><strong><a href="https://dev.opera.com/articles/responsive-images/" target="_blank">Статья с примерами обязательная к прочтению</a></strong></section><!-- SECTION --><section id="mobile-css"><h2>Mobile-first CSS</h2><p>Когда мы говорим об responsive веб-сайтах, термин mobile-first сразу приходит в голову. Для наших целей нам в первую очередь интересна медиа-функция min-width, которая позволяет применять конкретные стили CSS, если окно браузера опускается ниже определенной ширины, которую мы можем указать.</p><p>Медиазапросы, использующие min-width, чрезвычайно полезны, когда дело доходит до написания responsive веб-сайтов, поскольку это снижает сложность кода. Однако запросы минимальной ширины не являются панацеей, иногда бывает полезно добавить запросы max-width в таблицу стилей.</p><!-- subsection --><h3>Давайте рассмотрим пример</h3><p>У нас есть 4 блока на странице: хедер, список с 3-мя элементами, карта и футер. Дополнительно у нас есть два вспомогательных тега, container как общая обертка страницы и content как обертка для карты и списка. Слева отображено их расположение на телефоне. Справа на ноутбуке. Как вы думаете, в каком случае надо будет написать меньше css кода для позиционирования?</p><img src="./Модуль 8_files/m-first-ex-1.png" alt=""><p>Вспомним о потоке документа. Блоки в документе (по умолчанию) располагаются слева направо и сверху вниз. Думаю, вы уже догадались, что позиционировать элементы на картинке слева будет очень просто. Так как у нас элементы блочные достаточно просто написать html-разметку, и они встанут друг под другом. Плюсом будет то, что блочные элементы по умолчанию занимают 100% ширины родителя, поэтому нам не нужно в css задавать им явно ширину. Карты на узком экране нет, поэтому можем ее спрятать банальным display: none. В этом и есть сила mobile-first css.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_BdWPbK" src="./Модуль 8_files/BdWPbK.html" scrolling="no" frameborder="0" height="304" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-8-mobile-first" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p>Свойство <code>min-width</code> у <code>container</code>, это то значение ширины, ниже которого будет появляться полоса прокрутки. В современном вебе 320px считается минимально допустимой шириной экрана.</p></div><p>Заметьте, изначально даже нет media, так как стили пишутся для узкого экрана как база. Уже потом, при написании стилей для более широких экранов, мы добавляем media.</p><p>Теперь, используя mobile-first поход, добавим стили для более широкого экрана. Пусть для примера это будет 768px и шире. Добавим соответствующее media. Нам необходимо позиционировать карту и список рядом внутри content. Плюс карту нужно показать. Для примера дадим карте ширину 60%, а списку 40%. При верстке реального макета вы будете считать ширины блоков в % по формуле, которую мы изучили ранее.</p><div class="warn"><p>Представим ситуацию, когда мы начали делать верстку с более широкого экрана. То, что мы писали в media, мы бы написали без media, после чего на более узком экране нам бы пришлось в media переопределять display: flex для content, flex-basis для списка и карты и т.д. Думаю, вы уже видите преимущества modile-first css.</p></div><!-- subsection --><h3>Плюсы mobile-first css</h3><ul><li>Изначальный css более чистый, так как нам помогает поток документа и блочная модель при позиционировании элементов интерфейса</li><li>Наследование стилей от узких к широким экранам</li><li>Минимальное переопределение стилей позиционирования, следующее из первого пункта</li></ul><p>И все же, min-width при mobile-first не является панацеей. Есть задачи, при mobile-first верстке которых решения очень элегантны. Достаточно добавить max-width или гибрида min-width to max-width медиаправил.</p><div class="note"><p>По ссылке в дополнительных материалах вы можете наглядно разобрать пример такой ситуации, когда у нас есть, к примеру галерея, которая в зависимости от ширины экрана вмещает в строку разное количество элементов.</p></div></section><!-- SECTION --><section id="resources"><h2>Дополнительные материалы</h2><ul><li><a href="https://www.youtube.com/watch?v=Y5450Ns5L4M" target="_blank">Семинар от Yandex</a></li><li><a href="https://alistapart.com/article/responsive-web-design" target="_blank">Ethan Marcotte о отзывчивом веб дизайне</a></li><li><a href="https://www.fastcodesign.com/3038367/9-gifs-that-explain-responsive-design-brilliantly-2" target="_blank">Responsive vs Adaptive web design</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries" target="_blank">Media Queries на MDN</a></li><li><a href="https://css-tricks.com/responsive-images-css/" target="_blank">Responsive images на CSS-tricks</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images" target="_blank">Responsive images на MDN</a></li><li><a href="https://alistapart.com/article/responsive-images-in-practice" target="_blank">Статья о responsive images от Eric Portis</a></li><li><a href="https://zellwk.com/blog/how-to-write-mobile-first-css/" target="_blank">Статья о mobile-first css от Zell</a></li><li><a href="https://www.w3.org/TR/css3-mediaqueries/" target="_blank">W3C спек</a></li></ul></section></article><!-- ===== #page-navigator ======  --> <a href="http://fecore.net.ua/theory/module-8.html#main-nav" class="to-page-nav"></a><!-- ===== #end page-navigator =====  --></div></body></html>
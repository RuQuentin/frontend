<!DOCTYPE html>
<!-- saved from url=(0041)http://fecore.net.ua/theory/module-9.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,maximum-scale=1,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Модуль 9</title><link rel="stylesheet" href="./Модуль 9_files/styles.min.css"><script async="" src="./Модуль 9_files/ei.js.Без названия"></script><script async="" src="./Модуль 9_files/prism.js.Без названия"></script></head><body><div class="wrapper"><article><header><h1>Модуль 9 - Теория</h1><!-- ===== page-navigator =====  --><section class="table-of-contents" id="main-nav"><h2>Содержание</h2><ol class="page-nav"><li><a href="http://fecore.net.ua/theory/module-9.html#entry">Понятие модульной сетки</a></li><li><a href="http://fecore.net.ua/theory/module-9.html#using-grid">Работа с сеткой при верстке</a></li><li><a href="http://fecore.net.ua/theory/module-9.html#custom-grid">Пишем сетку с нуля</a></li><li><a href="http://fecore.net.ua/theory/module-9.html#frameworks">CSS Фреймворки</a></li><li><a href="http://fecore.net.ua/theory/module-9.html#bootstrap">Twitter Bootstrap 4</a></li><li><a href="http://fecore.net.ua/theory/module-9.html#css-grid">CSS grid</a></li><li><a href="http://fecore.net.ua/theory/module-9.html#pixel-perfect">Pixel perfect верстка</a></li><li><a href="http://fecore.net.ua/theory/module-9.html#resources">Дополнительные материалы</a></li></ol></section><!-- ====== end page-navigator =====  --></header><!-- SECTION --><section id="entry"><h2>Понятие модульной сетки</h2><p>Загляните в журнал или газету. В журнале информация традиционно разделена на две колонки, а в газете — на три-четыре, а то и больше. К примеру, страница Wall Street Journal разделена на 6 колонок. Заметьте, как пропорционально выглядит эта страница, даже расстояние между колонками равное. Это все благодаря сетке.</p><img src="./Модуль 9_files/newspaper-grid.jpg" alt=""><p>Зачем мы смотрим на газету? Затем что веб-дизайн довольно много разных «фишек» наследовал от полиграфического дизайна. Это и принципы работы со шрифтами, и правила композиции, и сетки с модулями. Именно благодаря полиграфии мы сегодня наслаждаемся удобством модульных сеток в вебе.</p><!-- subsection --><h3>Модульные сетки в веб-дизайне</h3><p><strong>Модульные сетки</strong> — система верстки, которая строит определенную композицию вашего сайта. Модульная сетка в web-дизайне представляет собой единую схему расположения всех элементов и блоков сайта. Этот каркас проходит через все веб-страницы и помогает создать визуальный порядок на сайте.</p><p>Вы уже создавали с помощью html-тегов таблицы, поэтому следующее сравнение будет для вас как нельзя кстати. Ведь сетку фреймворка можно сравнить с обычной таблицей. По сути, модульная сетка представляет собой набор вертикальных (возможно и горизонтальных) линий, к которым привязаны основные элементы сайта. Использование модульной сетки актуально для всех современных сайтов. Веб-страница фактически рассматривается как набор прямоугольных блоков, которые выкладываются в определенном порядке. При этом, как правило, данные располагаются по колонкам.</p><p>В макете модульная сетка представляет собой набор невидимых направляющих, вдоль которых располагаются элементы веб-страницы.</p><img src="./Модуль 9_files/grid-in-psd.png" alt=""><!-- subsection --><h3>Преимущества сетки</h3><p><strong>Скорость работы дизайнера</strong>: сетка облегчает размещение элементов в документе. Не нужно думать, что и где расположить, долго и хаотично перемещая элементы по макету. Есть определенные направляющие, которые уже интуитивно подсказывают, где лучше расположить элементы. Можно добавлять элементы не перегружая дизайн всего макета.</p><p><strong>Скорость и точность вёрстки</strong>: когда верстальщик пишет css, нет необходимости высчитывать ширины элементов интерфейса, достаточно задать нужное количество колонок для элементов интерфейса.</p><p><strong>Сбалансированность и пропорциональность</strong>: сетка обеспечивает визуальную связь между отдельными блоками и сохраняет преемственность дизайна при переходе от одной страницы к другой. Элементы в макете соизмеримы и пропорциональны между собой. Пользователь четко выделяет разделы и подразделы документа.</p><!-- subsection --><h3>Виды сеток</h3><ul><li><strong>Блочная (manuscript grid)</strong> - cамый простой вид сетки. Представляет собой грубо размеченную область — блок.</li><li><strong>Колоночная (column grid)</strong> - имеющая колонки в своей структуре.</li><li><strong>Модульная (modular grid)</strong> - состоящая из пересекающихся прямых, которые образуют модули. Модульная же сетка имеет не только вертикальное членение, но и горизонтальное. Таким образом, то, что получается на пересечениях прямых, и есть модуль.</li><li><strong>Иерархическая (hierarchical grid)</strong> - сетка с интуитивным размещением блоков, без какой-либо логической структуры.</li></ul><p>Нам интересны колоночная и модульная сетки, по сути, они похожи, модульная это расширение колоночной.</p></section><!-- SECTION --><section id="using-grid"><h2>Работа с сеткой при верстке</h2><p>Перед тем как начать знакомиться с сетками, разберемся с "типами" сетки в psd-макете. Их всего два, и для верстальщика между ними нет особой разницы. Итак, первый тип это когда сетка сделана направляющими в Photoshop. Такая сетка нужна для дизайнера, так как на ней удобно рисовать. Второй тип, это просто картинка с колонками, которая накладывается поверх всех слоев макета.</p><!-- subsection --><h3>Элементы сетки</h3><p>Для начала надо усвоить, что сетка состоит из:</p><ul><li><strong>Контейнера (container)</strong> - оборачивающий блок-контейнер, с ним мы уже знакомы из прошлого модуля. Именно ему мы задаем min и max width. Вся сетка должна располагаться в общем контейнере.</li><li><strong>Строка (row)</strong> - выступает контейнером для основного содержимого. В строках никакой контент не размещается, да и стили к ним не применяются. Они лежат непосредственно внутри container и занимают 100% его ширины.</li><li><strong>Колонок (ячеек, columns)</strong> - лежат внутри row. Они и есть мера ширины элемента интерфейса. К примеру, если на макете статья занимает 3 колонки в ширину, то и нам нужно будет просто указать при верстке ширину в 3 колонки, как это делается мы посмотрим дальше.</li><li><strong>Зазоры (gutters)</strong> - как и в типографии, между колонками есть зазоры. Они не обязательны, но чаще всего используются, для стандартизации отступов между элементами интерфейса. При необходимости их можно убрать.</li></ul><img src="./Модуль 9_files/grid-basics.png" alt=""><p>Основных величины три — это ширина сетки, ширина колонки (зависит от их количества), и ширина промежутка между колонками.</p><!-- subsection --><h3>Пример</h3><p>Если мы говорим о странице галереи из нашего веб-сайта, то можно разделить ее на четыре строки – шапка, блок для основного контента галереи и две строки на подвал. Думаю, вы уже видите, как удобно элементы интерфейса лежат внутри строк и их ширина всегда равна определенному количеству колонок.</p><img src="./Модуль 9_files/grid-example.jpg" alt=""></section><!-- SECTION --><section id="custom-grid"><h2>Пишем сетку с нуля</h2><p>Для лучшего понимания, мы с вами напишем простую 12-ти колоночную сетку на флексах. Она будет в себя включать контейнер, строки и колонки с отступами. Итак, что такое сетка - это всего лишь набор классов с заранее прописанными css-правилами. Настолько просто.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_yoaJaE" src="./Модуль 9_files/yoaJaE.html" scrolling="no" frameborder="0" height="288" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-9-simple-grid" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Container</h3><p>Так как контейнер не имеет никакого семантического значения, то для него мы будем использовать простой div. Создадим класс container. Ему задаем min и max width, и margin для горизонтального центрирования.</p><!-- subsection --><h3>Row</h3><p>Далее нам нужно определить строку. Она тоже не несет никакого семантического значения, но в отличие от контейнера должна располагать в себе колонки. Если колонки не влезут в текущую строку, они переносятся на следующую строку внутри row. Грубо говоря, row у нас будет flex-контейнером. Зададим flex свойства.</p><!-- subsection --><h3>Columns</h3><p>Мы уже знаем о правилах верстки, используя относительные единицы измерения, проценты, и правила расчета ширины блока внутри родителя. У нас есть 12 колонок, и ширина контейнера берется за 100%, значит:</p><p class="accent">ширина одной колонки = 100% / 12 = 8.333%</p><p>Далее все просто. Создадим класс col, теперь нам нужно сделать их 12 штук, от col-1 до col-12. Возможно, вы уже догадались, цифра в имени класса указывает ширину, которую данный блок будет занимать в колонках. После чего ширину колонки мы высчитываем, умножая это число на ширину одной колонки.</p><!-- subsection --><h3>Gutters</h3><p>Для задания отступов между колонками мы используем padding самих колонок, слева и справа по 0.5rem. Тут появляется проблема: первая и последняя колонка визуально отступают от края row на свой padding. Когда мы будет делать вложенные строки это, будет проблемой. Чтобы сразу решить это проблему мы для row задаем отрицательный margin в -0.5rem.</p><!-- subsection --><h3>Используем сетку</h3><p>Итого у нас с вами получилась простая, не респонсив, flex-сетка. Напишем что-то, используя нашу новую сетку. Сделаем разметку из двух сайдбаров и контентной области. Пусть левый сайдбар занимает 3 колонки, правый 2 колонки, тогда контентная будет 7 колонок в ширину. Создаем контейнер, в него вставим строку, в строку колонки, в колонки уже кладем элементы интерфейса.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_brweqo" src="./Модуль 9_files/brweqo.html" scrolling="no" frameborder="0" height="313" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-9-simple-grid-example" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p>Имена классов, которые мы задали нашим элементам сетки, а так же идея построения сетки, идентичны или очень похожи в большинстве сеток. Думаю, все стало на свои места. Далее мы поговорим о готовых решениях, которые стоит использовать в работе.</p></div></section><!-- SECTION --><section id="frameworks"><h2>CSS Фреймворки</h2><p>Давайте поговорим о том, где собственно взять готовую респосив-сетку. Есть десятки, если не сотни, всевозможнейших сеток. Одни, это просто наборы css-классов, другие же входят в состав так называемых фреймворков.</p><p><strong>CSS фреймворк</strong> - заранее готовый набор html-конструкций и css-классов для быстрого составления прототипа веб-страницы. Прежде всего, упрощает работу верстальщика, ускоряет процесс разработки и исключает возможные ошибки.</p><p>Практически, если мы рассматриваем, для чего вообще создается css-фреймворк, то во многом только для сетки, которая позволяет быстро и легко верстать адаптивные шаблоны. Остальные компоненты вроде кнопок, таблиц, форм и прочего можно сделать и самому, зачастую именно так и нужно.</p><p>На сегодняшний день существует невероятное количество css-фреймворков. Каждый из них включает в себя систему responsive-сетки, наличие большого количества разнообразных компонентов, кнопок, выпадающих меню, заголовков, списков и другого полезного. Давайте перечислим несколько самых популярных.</p><ul><li>Twitter Bootstrap</li><li>Foundation</li><li>Semantic UI</li><li>Skeleton</li><li>Materialize</li></ul><p>Мы с вами рассмотрим сетку из Twitter Bootstrap, на сегодняшний день это один из самых популярных фреймворков. Понимая как использовать его, вы без проблем освоите любой другой.</p></section><!-- SECTION --><section id="bootstrap"><h2>Twitter Bootstrap 4</h2><p>Итак, сетка в Bootstrap 4 построена на флексах, что добавило много приятных фишек, в 3-й версии использовались флоаты. По умолчанию в ней 12 колонок. Она полностью responsive и построена используя mobile-first подход.</p><p>Фреймворк можно настраивать под себя, он имеет широкий спектр опций, для этого необходимо перейти на страницу кастомизации и выбрать необходимые пункты. Настройка Bootstrap выходит за рамки этого урока, вы можете более глубокого ознакомиться с фреймворком по ссылкам в дополнительных материалах.</p><!-- subsection --><h3>Добавляем Bootstrap в проект</h3><p>Есть несколько методов как добавить Bootstrap в проект. Сейчас нам подходят 2, скачать исходные файлы или подключить, используя CDN-ссылку. Это самый обычный файл стилей.</p><p>Bootstrap включает в себя много css-стилей по умолчанию, в общем, это очень похоже на знакомый нам <code>normalize.css</code>.</p><pre class=" language-markup"><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css<span class="token punctuation">"</span></span> <span class="token attr-name">integrity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>anonymous<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span></code></pre><!-- subsection --><h3>Сетка Bootstrap</h3><p>Вспомним сетку, которую мы с вами написали выше. По идеологии она не отличается от сетки Bootstrap. Те же: container, row, col, gutter. Конечно, сетка Bootstrap значительно богаче в плане функционала, к тому же она responsive. Давайте более детально рассмотрим все эти элементы.</p><!-- subsection --><h4>Container</h4><p>В Bootstrap сетке есть 2 класса для контейнера.</p><ul><li><strong>container</strong> - описывает контейнер "фиксированной" ширины, имеется ввиду, что это блок, у которого есть max-width в пикселях.</li><li><strong>container-fluid</strong> - описывает контейнер с width в 100%, то есть он всегда занимает 100% ширины экрана.</li></ul><!-- subsection --><h4>Rows</h4><p>Строки представляют собой горизонтальные группы столбцов, которые обеспечивают их правильное выравнивание. Строки имеют отрицательный margin, чтобы обеспечить правильное выравнивание содержимого.</p><!-- subsection --><h4>Columns</h4><p>Классы столбцов указывают количество столбцов, которые вы хотели бы использовать, из возможных 12 в строке. Ширины столбцов задаются в процентах, поэтому их ширина всегда резиновая относительно ширины родителя. Столбцы имеют горизонтальный padding для создания gutters между отдельными столбцами. Содержимое должно быть помещено в столбцы, и только столбцы могут быть непосредственными дочерними элементами строк.</p><div class="note"><p>Обратите внимание, все абсолютно так, как было в нашей с вами простой сетке, вы это уже знаете! :]</p></div><!-- subsection --><h4>Уровни сетки</h4><p>Сетка Bootstrap поддерживает responsive-верстку, нужно более детально остановиться на этом пункте.</p><p>Есть пять уровней сетки, по одному для каждой точки перелома: extra small, small, medium,large, и extra large.</p><p>Поскольку Bootstrap разработан используя mobile-first подход, в нем используются несколько медиа-запросов для создания переломных точек.</p><table><tbody><tr><th>Медиаправило</th><th>Префикс класса</th><th>Описание</th></tr><tr><td>Медиаправила нет</td><td>нет</td><td>Очень маленькие устройства (портретные телефоны, меньше чем 576px). Это дефолтные стили.</td></tr><tr><td>@media (min-width: 576px)</td><td>sm</td><td>Маленькие устройства (альбомные телефоны, 576 пикселей и выше)</td></tr><tr><td>@media (min-width: 768px)</td><td>md</td><td>Средние устройства (планшеты, 768px и выше)</td></tr><tr><td>@media (min-width: 992px)</td><td>lg</td><td>Большие устройства (настольные компьютеры, 992px и выше)</td></tr><tr><td>@media (min-width: 1200px)</td><td>xl</td><td>Экстра большие устройства (большие настольные компьютеры, 1200 пикселей и выше)</td></tr></tbody></table><div class="note"><p><strong>Внимание:</strong> уровни сетки основаны на минимальной ширине, то есть они применяются к одному уровню и всем вышеперечисленным (например, <code>.col-sm-4</code> применяется к малым, средним, большим и сверхбольшим устройствам).</p></div><!-- subsection --><h3>Правила записи классов колонок</h3><p>Колонка имеет класс <code>col-x-x</code>, где первый x – обозначение устройства, а второй – кол-во колонок от 1 до 12. Для самых маленьких устройств нет префикса, класс записывается как col-x, где x это кол-во колонок. Как это работает, мы с вами сейчас посмотрим.</p><p>Разработчики фреймворка при создании сетки выделили 5 основных типов устройств по ширине экрана. С ними мы познакомились в таблице уровней сетки. К примеру, для маленьких устройств, префикс класса - sm. Поэтому если нам нужно чтобы элемент интерфейса занимал, к примеру, 3 колонки на маленьких экранах и выше, мы задаем класс col-xs-3.</p><p>Применится вот такое медиаправило из таблицы <code>@media (min-width: 576px)</code>, при котором ширина блока будет равна 3-м колонкам от 576px и выше. Думаю понятно, но давайте рассмотрим пример.</p><p>Есть контейнер и одна строка. В строке 2 колонки, в каждой колонке какой-то элемент интерфейса. Пусть это будут сайдбар и контент. Допустим, у нас по макету при маленьких экранах сайдбар и контент идет в столбик. После чего на средних экранах они стоят в строку и занимают 3 и 9 колонок. На экранах широких они все так же в строку и занимают 4 и 8 колонок.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_XajKVw" src="./Модуль 9_files/XajKVw.html" scrolling="no" frameborder="0" height="254" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-9-bootstrap-4-basics" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p><strong>Внимание:</strong> из этого можно сделать выводы, перечитайте их несколько раз, потому что понять эти вещи крайне важно.</p></div><ul><li>Если мы задаем, например, <code>col-sm-6</code>, то такая ширина сохранится у блока и на <code>md</code> и <code>lg</code>, если для этих устройств ничего не прописано.</li><li>Возьмем этот же пример <code>col-sm-6</code>. Как вы думаете, какая ширина блока будет при ширине экрана ниже 576px? Ответ - 100%, а не 50%. Почему? - наследование прописанной ширины происходит только для более широких устройств, но не для менее широких. Например, если мы напишем блоку ТОЛЬКО класс <code>col-lg-6</code>, такая ширина у блока будет на экранах шире, чем 992px. На <code>xs</code>, <code>sm</code>, <code>lg</code> устройствах будет другая ширина.</li><li>Мы можем указывать блоку не один, а несколько классов, до максимума - 1 класс на одно устройство.</li></ul><!-- subsection --><h3>Вложенные сетки</h3><p>Но мощь сетки Bootstrap не только в том, что вы можете задать разное отображение блоков на разной ширине. А еще в том, что можно вкладывать сетку в какой угодно блок. Давайте рассмотрим такой пример кода:</p><div class="cp_embed_wrapper"><iframe id="cp_embed_mMrExW" src="./Модуль 9_files/mMrExW.html" scrolling="no" frameborder="0" height="301" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-9-bootstrap-4-nesting" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p>Итак, у нас есть общий контейнер, а в нем один ряд. В ряд вложены блоки sidebar и content, они занимают по 12 колонок на узких экранах, 3 и 9 колонок на средних, 4 и 8 на больших. Но ведь мы можем спокойно себе представить, что блок content является тоже контейнером, почему нет? По сути, так и есть при разработке сайта. Есть общий контейнер для всего сайта, контейнер для контента, сайдбара, шапки и т.д. Если content это контейнер для контента внутри себя, то в него мы помещаем строку (обязательно придерживайтесь в коде структуры: контейнер – ряд — ячейки).</p><p>В этой строке, как видите, 4 блока и для каждого задано поведение на разных устройствах. По сути, мы получили сетку внутри основной сетки! И эта вложенная сетка тоже будет иметь 12 колонок. Вложенных сеток может быть неограниченное количество. Например, эти четыре блока – это три карточки товара в интернет-магазине. Структура самой карточки может быть тоже достаточно сложной. Кто знает, может и там вы используете вложенную сетку.</p><div class="note"><p>Таким образом, Bootstrap попросту стирает перед вами любые препятствия при верстке веб-страниц: вы можете создать как простые типовые шаблоны, так и сложнейшие страницы стысячей элементов на них.</p></div><!-- subsection --><h3>Вертикальное и горизонтальное выравнивание</h3><p>Благодаря тому, что Bootstrap 4 сетка реализована на Flexbox, в наше распоряжение поступили очень полезные и удобные классы горизонтального и вертикального выравнивания колонок внутри строки. Вы уже знаете Flexbox, поэтому углубляться мы не будем. Просто рассмотрим список классов.</p><p class="accent">Для row</p><table><tbody><tr><th>Класс</th><th>Поведение</th></tr><tr><td>justify-content-start</td><td>Прижимает колонки к началу основной оси строки</td></tr><tr><td>justify-content-center</td><td>Центрирует колонки на основной оси строки</td></tr><tr><td>justify-content-end</td><td>Прижимает колонки к концу основной оси строки</td></tr><tr><td>justify-content-between</td><td>Равномерно распределяет колонки на основной оси</td></tr><tr><td>justify-content-around</td><td>Равномерно распределяет колонки на основной оси, в начале и конце основной оси создается пустое пространство</td></tr><tr><td>align-items-start</td><td>Прижимает колонки к началу поперечной оси строки</td></tr><tr><td>align-items-center</td><td>Центрирует колонки на поперечной оси строки</td></tr><tr><td>align-items-end</td><td>Прижимает колонки к концу поперечной оси строки</td></tr></tbody></table><p class="accent">Для col</p><table><tbody><tr><th>Класс</th><th>Поведение</th></tr><tr><td>align-self-start</td><td>Прижимает колонку к началу поперечной оси строки</td></tr><tr><td>align-self-center</td><td>Центрирует колонку на поперечной оси строки</td></tr><tr><td>align-self-end</td><td>Прижимает колонку к концу поперечной оси строки</td></tr></tbody></table><p class="accent">Пример</p><div class="cp_embed_wrapper"><iframe id="cp_embed_wqzege" src="./Модуль 9_files/wqzege.html" scrolling="no" frameborder="0" height="452" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-9-bootstrap-4-align" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Адаптивные утилиты</h3><p>Еще одна полезная возможность фреймворка – адаптивные утилиты. Довольно часто на мобильных устройствах не отображают 100% элементов сайта, которые видны на больших десктопах – попросту некуда будет все это поместить. Очень часто, на мобильных устройствах, полностью убирают боковую колонку, сворачивают меню, удаляют какие-то большие декоративные элементы и т.д.</p><p>В Bootstrap все это очень легко делать с помощью классов, которые называют адаптивными утилитами. Адаптивные утилиты позволяют как угодно трансформировать сайт на всех типах устройств. Используйте их по мере необходимости в своей верстке.</p><p><a href="https://getbootstrap.com/docs/4.0/utilities/display/" target="_blank">Документация по утилитам отображения</a></p><div class="note"><p>Очень много еще можно написать о сетке бутстрапа и самом фреймворке, мы рассмотрели только часть функционала. С остальными классами и примерами вы можете ознакомиться в <a href="https://getbootstrap.com/docs/4.0/getting-started/introduction/" target="_blank">официальной документации</a>.</p></div></section><!-- SECTION --><section id="css-grid"><h2>CSS grid</h2><p>Необходимо сказать пару слов о новом стандарте сеток - CSS Grid. Она официально вышла в марте 2017 года, сейчас ведутся активные работы по ее имплементации в браузеры и фикс багов. В ближайшие годы она станет стандартом для сеток в вебе.</p><p>Главное отличие CSS Grid от классических сеток в том, что используя, к примеру, Bootstrap сетку, мы сначала создаем элементы интерфейса, после чего из них набираем сетку. Используя CSS Grid все наоборот, сначала составляется сетка веб-страницы, после чего в ячейки кладутся элементы интерфейса. Чем-то похоже на иерархическую сетку.</p><div class="note"><p>В дополнительных материалах есть ссылки на рекомендованные ресурсы для ознакомления, если вам интересно.</p></div></section><!-- SECTION --><section id="pixel-perfect"><h2>Pixel perfect верстка</h2><p>Что такое Pixel Perfect верстка? Все просто и можно догадаться по названию - это техника верстки, при которой сверстанный HTML-шаблон в точности (пиксель-в-пиксель) совпадает с оригиналом, PSD-макетом.</p><p>Другими словами, если наложить “картинку” сверстанного HTML-шаблона на картинку оригинального PSD-макета, то обе картинки должны совпасть. Совместиться должны все элементы картинок - текст, изображения, графические элементы.</p><p>По современным требованиям к верстке Pixel Perfect уже чуть ли не стандарт де-факто. К счастью нам во многом помогают сетки. Макет рисуется на сетке, значит, если мы верно сделали расстановку элементов интерфейса на сетке, половина работы уже сделана. Останется только сделать Pixel Perfect верстку внутри элементов интерфейса.</p><!-- subsection --><h3>Инструменты</h3><p>Вспомогательные инструменты для Pixel Perfect верстки можно разделить на 2 категории: с использованием скриптов и без них. На данном этапе нам интересна вторая группа. Это плагины для браузеров, в частности PerfectPixel.</p><!-- subsection --><h3>Использование</h3><p>Приведем список шагов необходимых для работы с PerfectPixel:</p><ul><li>Установить плагин PerfectPixel для вашего браузера</li><li>В Photoshop оригинальный PSD-макет сохранить как изображение в формате png.</li><li>Затем в браузере открывается сверстанная по макету страница.</li><li>При помощи плагина PNG-копия макета накладывается на сверстанную страницу. И становится видна разница в расположении элементов на HTML-странице и на PNG-копии.</li></ul><p>В этом и заключается вся несложная процедура Pixel Perfect проверки сверстанной страницы. Там, где на странице элементы не совпадают с оригиналом, производится коррекция значений в файлах стилей.</p><!--<div class="note">--><!--<p>Более детальное пояснение процесса работы с плагином PerfectPixel представлено в--><!--скринкасте к этому--><!--модулю.</p>--><!--</div>--></section><!-- SECTION --><section id="resources"><h2>Дополнительные материалы</h2><ul><li><a href="http://vanseodesign.com/web-design/grid-types/" target="_blank">Типы сеток</a></li><li><a href="https://getbootstrap.com/docs/4.0/getting-started/introduction/" target="_blank">Bootstrap docs</a></li><li><a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank">CSS grid на CSS-tricks</a></li><li><a href="http://www.welldonecode.com/perfectpixel/" target="_blank">Домашняя страница PerfectPixel</a></li><li><a href="https://www.smashingmagazine.com/2011/08/the-semantic-grid-system-page-layout-for-tomorrow/22/" target="_blank">Статья о семантичных сетках</a></li></ul></section></article><!-- ===== #page-navigator ======  --> <a href="http://fecore.net.ua/theory/module-9.html#main-nav" class="to-page-nav"></a><!-- ===== #end page-navigator =====  --></div></body></html>
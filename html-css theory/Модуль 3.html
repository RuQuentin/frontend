<!DOCTYPE html>
<!-- saved from url=(0041)http://fecore.net.ua/theory/module-3.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,maximum-scale=1,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Модуль 3</title><link rel="stylesheet" href="./Модуль 3_files/styles.min.css"><script async="" src="./Модуль 3_files/ei.js.Без названия"></script><script async="" src="./Модуль 3_files/prism.js.Без названия"></script></head><body><div class="wrapper"><article><header><h1>Модуль 3 - Теория</h1><!-- ===== page-navigator =====  --><section class="table-of-contents" id="main-nav"><h2>Содержание</h2><ol class="page-nav"><li><a href="http://fecore.net.ua/theory/module-3.html#intro">Технология CSS</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#syntax">Синтаксис CSS</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#adding-css">Виды таблиц стилей</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#selectors">Виды селекторов</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#grouping">Группировка селекторов</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#cascade">Наследование, каскад, специфичность</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#box-model">Модель визуального форматирования</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#block-and-inline">Блочные и строчные элементы</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#margin">Особенности margin</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#align">Горизонтальное и вертикальное выравнивание</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#styling-text">Оформление текста</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#background">Фон</a></li><li><a href="http://fecore.net.ua/theory/module-3.html#resources">Дополнительные материалы</a></li></ol></section><!-- ====== end page-navigator =====  --></header><!-- SECTION --><section id="intro"><h2>Технология CSS</h2><p><strong>CSS (Cascading Style Sheets)</strong> - каскадные таблицы стилей, это язык, используемый для описания оформления документа, написанного языком разметки, таким как HTML.</p><p>В то время как HTML используется для определения структуры и семантики содержимого документа, CSS используется для его стилизации и позиционирования. Каскадные таблицы стилей описывают правила форматирования элементов с помощью свойств и допустимых значений этих свойств. Для каждого элемента можно использовать ограниченный набор свойств, остальные свойства не будут оказывать на него никакого влияния.</p></section><!-- SECTION --><section id="syntax"><h2>Синтаксис CSS</h2><p>Синтаксис CSS очень простой, объявление стиля состоит из двух частей: элемента веб-страницы — селектора и команды форматирования — блока объявления. Вначале пишется имя селектора, например body, это означает, что все стилевые параметры будут применяться к тегу <code>body</code>, затем идут фигурные скобки, в которых записывается стилевое свойство, а его значение указывается после двоеточия.</p><img src="./Модуль 3_files/module-3-css-syntax.png" alt=""><p><code>CSS правило</code> - это конструкция, которая связывает 1 или более селекторов с одним или более свойств CSS.</p><p><code>Селектор (selector)</code> - указывая его, мы говорим браузеру, к чему именно хотим применить css правило (html-тег, id, класс и т.д.).</p><p><code>Блок объявлений (declaration block)</code> - так называется всё содержимое, находящееся между фигурными скобками {} после селектора.</p><p><code>Свойство (property)</code> - идентификатор действия, которое будет применено к элементу (например, вы хотите изменить начертание шрифта font-weight, цвет color, размер шрифта font-size и т. д.). После имени свойства необходимо ставить двоеточие.</p><p><code>Значение (value)</code> - описывает, как именно свойство будет обработано браузером. Каждое свойство имеет набор допустимых значений, определенных формальными правилами, а также семантический смысл, реализованный движком браузера. Записывается после двоеточия.</p></section><!-- SECTION --><section id="adding-css"><h2>Виды таблиц стилей</h2><!-- subsection --><h3>Встроенные стили</h3><p>Стили прописываются непосредственно в атрибуте <code>style</code> самого тега элемента, к которому мы хотим их применить.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_xLPreE" src="./Модуль 3_files/xLPreE.html" scrolling="no" frameborder="0" height="120" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-inline-css" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Внутренние стили</h3><p>Стили прописываются в теге <code>style</code>, который размещается в <code>head</code>.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_LjdwbE" src="./Модуль 3_files/LjdwbE.html" scrolling="no" frameborder="0" height="255" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-style-tag" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Внешняя таблица стилей</h3><p>Внешняя таблица стилей описывается во внешнем файле с расширением <code>.css</code>, после чего он подключается к документу, используя тег <code>link</code>. Внутри файла могут содержаться только стили. К каждой веб-странице можно присоединить несколько таблиц стилей, добавляя последовательно несколько тегов <code>link</code>. На сегодняшний день это стандарт подключения стилей к документу.</p><ul><li>На одном уровне с index.html создается папка css</li><li>Внутри папки css создается файл стилей, к примеру, styles.css</li><li>В теге head, используя тег link, подключаем созданный ранее файл стилей. В атрибут href тега link значением записываем путь к файлу стилей, относительно index.html</li></ul><pre class=" language-markup"><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>css/styles.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span></code></pre><h4>Правило @import</h4><p>Правило @import позволяет загружать внешние таблицы стилей в другие таблицы стилей. Чтобы директива @import работала, она должна располагаться в таблице стилей (внешней или внутренней) перед всеми остальными правилами.</p><pre class=" language-css"><code class=" language-css"><span class="token comment">/* styles.css */</span>
<span class="token atrule"><span class="token rule">@import</span> <span class="token url">url(theme.css)</span><span class="token punctuation">;</span></span></code></pre></section><!-- SECTION --><section id="selectors"><h2>Виды селекторов</h2><p>Селекторы представляют структуру веб-страницы. С их помощью создаются правила для форматирования элементов веб-страницы. Селекторами могут быть элементы, их классы и идентификаторы, а также псевдоклассы и псевдоэлементы.</p><p><strong>Универсальный селектор</strong> - соответствует любому HTML-элементу</p><p><strong>Селектор элемента</strong> - описывает, к какому типу элемента будет применено css правило, после чего свойства будут применены ко всем элемента данного типа.</p><p><strong>Селектор класса</strong> - тегам можно задать специальный атрибут <code>class</code>. После чего мы можем использовать селектор класса, чтобы задавать стили для одного и более элементов с одинаковым именем класса, размещенных в разных местах страницы. В CSS перед именем класса ставится точка <span class="accent">.</span></p><p><strong>Селектор идентификатора</strong> - как и с классом, тегам можно задавать атрибут <code>id</code>. Отличие в том, что id должен быть уникальным на странице, это значит, что селетор id позволяет форматировать один конкретный элемент. В CSS перед идентификатором ставится решетка <span class="accent">#</span></p><p><strong>Селектор потомка</strong> - применяет стили к элементам, расположенным внутри элемента-контейнера. Если нужно отформатировать потомки определенного элемента, этому элементу нужно задать стилевой класс.</p><p><strong>Дочерний селектор</strong> - дочерний элемент является прямым потомком содержащего его элемента. У одного элемента может быть несколько дочерних элементов, а родительский элемент у каждого элемента может быть только один. Дочерний селектор позволяет применить стили только, если дочерний элемент идёт сразу за родительским элементом, и между ними нет других элементов, то есть дочерний элемент больше ни во что не вложен.</p><p><strong>Сестринский селектор</strong> - сестринские отношения возникают между элементами, имеющими общего родителя. Селекторы сестринских элементов позволяют выбрать элементы из группы элементов одного уровня.</p><p><strong>Селектор атрибута</strong> - выбирает элементы на основе имени атрибута или значения атрибута.</p><p><strong>Селектор псевдокласса</strong> - псевдоклассы это состояния элемента. Они позволяют применить CSS-правила к элементам при совершении события или подчиняющимся определенному правилу.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_eEKdLb" src="./Модуль 3_files/eEKdLb.html" scrolling="no" frameborder="0" height="430" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-selectors" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section><!-- SECTION --><section id="grouping"><h2>Группировка селекторов</h2><p>Один и тот же стиль можно одновременно применить к нескольким элементам. Для этого необходимо перечислить через запятую нужные селекторы.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_oedNBQ" src="./Модуль 3_files/oedNBQ.html" scrolling="no" frameborder="0" height="284" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-multiple-selectors  " class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section><!-- SECTION --><section id="cascade"><h2>Наследование, каскад, специфичность</h2><p>Наследование и каскад — два важных понятия в CSS, которые тесно связаны. Наследование заключается в том, что элементы наследуют свойства от содержащего их элемента (родителя). Каскад проявляется в том, как разные виды таблиц стилей применяются к документу, и как конфликтующие правила переопределяют друг друга.</p><!-- subsection --><h3>Наследование</h3><p>Наследование является механизмом, с помощью которого определенные свойства передаются от предка к его потомкам. Спецификацией CSS предусмотрено наследование свойств, относящихся к текстовому содержимому страницы, таких как color, font, text-align и т.д. Во многих случаях это удобно, так как не нужно задавать размер шрифта и семейство шрифтов для каждого элемента веб-страницы.</p><ul><li>Стили могут наследоваться от родительского элемента</li><li>Стили, расположенные в таблице стилей ниже, отменяют стили, расположенные в таблице выше</li><li>К одному элементу могут применяться стили из разных источников. Проверить, какие стили применяются, можно в инструментах разработчика</li><li>При определении стиля можно использовать любую комбинацию селекторов — селектор элемента, псевдокласса элемента, класса или идентификатора элемента</li></ul><div class="note"><p>Свойства, относящиеся к форматированию блоков, не наследуются. Такие как background, border, display, width и т.д.</p></div><h3>Каскад</h3><p>Каскадирование — это механизм, который управляет конечным результатом в ситуации, когда к одному элементу применяются разные CSS-правила. Существует три критерия, которые определяют порядок применения свойств — правило !important, специфичность и порядок, в котором подключены таблицы стилей.</p><h4>Правило !important</h4><p>Вес правила можно задать с помощью ключевого слова <code>!important</code>, которое добавляется сразу после значения свойства. Правило необходимо размещать в конец объявления перед закрывающей скобкой, без пробела. Такое объявление будет иметь приоритет над всеми остальными правилами. Это правило позволяет отменить значение свойства и установить новое для элемента из группы элементов в случае, когда нет прямого доступа к файлу со стилями.</p><div class="warn"><p>Крайне не рекомендуется использовать <code>!important</code> в современной разработке.</p></div><h3>Специфичность</h3><p>Для каждого правила браузер вычисляет специфичность селектора, и если у элемента имеются конфликтующие объявления свойств, во внимание принимается правило, имеющее наибольшую специфичность. Значение специфичности состоит из четырех частей: 0, 0, 0, 0. В результате к элементу применятся те правила, специфичность которых больше.</p><p>Специфичность селектора определяется следующим образом:</p><ul><li>за каждый id добавляется единица в третий разряд - 0, 1, 0, 0</li><li>за каждый class добавляется единица во второй разряд - 0, 0, 1, 0</li><li>за каждый элемент и псевдоэлемент добавляется единица в первый разряд - 0, 0, 0, 1</li><li>для встроенного стиля, добавленного непосредственно к элементу, добавляется единица в четвертый разряд — 1, 0, 0, 0</li></ul><div class="cp_embed_wrapper"><iframe id="cp_embed_xLpjad" src="./Модуль 3_files/xLpjad.html" scrolling="no" frameborder="0" height="237" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-specificity" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p>В статье по <strong><a href="https://habrahabr.ru/post/137588/" target="_blank">ссылке</a> </strong>вы можете более детально ознакомиться с правилами вычисления веса селектора.</p></div></section><!-- SECTION --><section id="box-model"><h2>Модель визуального форматирования</h2><p>Модель визуального форматирования CSS представляет собой алгоритм, который обрабатывает HTML-документ и выводит его на экран устройства. Данная модель преобразует каждый элемент документа таким образом, что он генерирует ноль или более прямоугольных боксов в соответствии с блочной моделью CSS</p><!-- subsection --><h3>Блочная модель</h3><p>В блочной модели элемент рассматривается как прямоугольный контейнер, имеющий область содержимого и необязательные поля, рамки и отступы. Свойство <code>display</code> определяет тип контейнера элемента. Для каждого элемента существует значение браузера по умолчанию.</p><img src="./Модуль 3_files/box-model.png" alt=""><p><strong>Область содержимого (content)</strong> — это содержимое элемента, например, текст или изображение.</p><p><strong>Внутреннее поле (padding)</strong> — это расстояние между основным содержимым и его границей (border). Если для элемента задать фон, то он распространится также и на поля элемента. Внутренний отступ не может принимать отрицательных значений.</p><p><strong>Внешний отступ (margin)</strong> - добавляет отступ снаружи элемента от внешней границы рамки (border) до соседних элементов, тем самым разделяя элементы на странице. Внешние отступы всегда остаются прозрачными и через них виден фон родительского элемента. Может принимать отрицательное значение. Не обязателен, по умолчанию значение равно нулю.</p><p><strong>Граница, или рамка (border)</strong> - если цвет рамки не задан, она принимает цвет основного содержимого элемента, например, текста. Если рамка имеет разрывы, то сквозь них будет проступать фон элемента. Не обязателен, по умолчанию значение равно нулю.</p><h3>Подвиды блочной модели</h3><p>Существует несколько блочных моделей. Они отличаются расчетом финального размера блока. Для изменения модели используется свойство <code>box-sizing</code>.</p><h4>Content box</h4><p>content-box включена в браузерах по умолчанию, контринтуитивна. Поставив ширину 100px, padding 20px и border 10px, мы получим 100px ширину content area плюс по 20px padding(левый и правый) и по 10px border (левый и правый), итого полная ширина будет равна 100+20+20+10+10 = 160px. Хотя ширину блока мы указали 100px. Аналогично рассчитывается высота.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_prVwQW" src="./Модуль 3_files/prVwQW.html" scrolling="no" frameborder="0" height="265" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-content-box" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><figure><img src="./Модуль 3_files/content-box.png" alt=""><figcaption>В результате получится блок cо следующими размерами</figcaption></figure><h4>Border box</h4><p>В отличие от content-box, при border-box width и height описывают финальные, желаемые размеры блока, а не контентной области. Контентная область как-бы сжимается чтобы "внутри" блока еще вместился padding и border.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_MvGvEz" src="./Модуль 3_files/MvGvEz.html" scrolling="no" frameborder="0" height="238" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-border-box " class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><figure><img src="./Модуль 3_files/border-box.png" alt=""><figcaption>В результате получится блок cо следующими размерами</figcaption></figure></section><!-- SECTION --><section id="block-and-inline"><h2>Блочные и строчные элементы</h2><!-- subsection --><h3>Блочные элементы</h3><p><strong>Блочные элементы (display: block)</strong> — элементы, которые форматируются визуально как блоки, располагаясь на странице в окне браузера вертикально. Они создают разрыв строки перед элементом и после него, образуя прямоугольную область, по ширине занимающую всю ширину веб-страницы или блока-родителя (если для элемента не задано значение width). Это элементы div, h1-h6, p, ol, ul, li и многие другие.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_jLxLvv" src="./Модуль 3_files/jLxLvv.html" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-block-el" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Строчные элементы</h3><p><strong>Строчные (display: inline)</strong> - элементы, которые генерируют внутристрочные контейнеры. Они не формируют новые блоки контента.</p><p>Они игнорируют верхние и нижние margin и padding, но если для элемента задан фон, он будет распространяться на верхний и нижний padding, заходя на соседние строки текста.</p><p>Ширина и высота строчного элемента зависит только от его содержимого, задать размеры с помощью CSS нельзя. Можно увеличить расстояние между соседними элементами по горизонтали с помощью горизонтальных полей и отступов.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_LjmjMN" src="./Модуль 3_files/LjmjMN.html" scrolling="no" frameborder="0" height="190" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-inline-el  " class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p>Строчные элементы могут содержать только данные и другие строчные элементы. Исключение составляет элемент <span class="accent">&lt;a&gt;</span>, который согласно спецификации HTML5 может оборачивать целые абзацы, списки, таблицы, заголовки и целые разделы при условии, что они не содержат другие интерактивные элементы — другие ссылки и кнопки.</p></div><!-- subsection --><h3>Строчно-блочные элементы</h3><p><strong>Cтрочно-блочные (display: inline-block)</strong> - такие элементы являются встроенным, но для них можно задавать поля, отступы, ширину и высоту.</p><p>Для того чтобы верхние и нижние поля и отступы работали для строчного элемента, нужно использовать display: inline-block. Элемент останется строчным, но к нему можно будет полноценно применить поля, отступы, задать ширину и высоту.</p><!-- subsection --><h3>Преобразование типов элементов</h3><p>В некоторых случаях бывает необходимо, чтобы строчный элемент вел себя как блочный и наоборот. Значение свойства display у элемента можно менять по необходимости на любое другое. Можно превратить строчный в блочный или строчно-блочный или наоборот. Это стандартная практика при верстке.</p><figure><img src="./Модуль 3_files/html-layout-example.png" alt=""><figcaption>Допустим нам надо сверстать такую структуру документа</figcaption></figure><p>У нас все элементы блочные (div), но content и sidebar надо поставить в одну строку, по умолчанию с блочными элементами так сделать не получится. Поэтому мы нашим content и sidebar меняем display на inline-block. После чего задаем им какие-то ширины (в примере ширины в % от общей ширины, для красоты), и вот они уже стоят в одной строке, так как теперь они строчно-блочные и если их общая ширина помещается в одну строку, мы получим желаемый результат.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_ZJoaqv" src="./Модуль 3_files/ZJoaqv.html" scrolling="no" frameborder="0" height="353" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-display-prop" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p>По <strong><a href="https://css-tricks.com/fighting-the-space-between-inline-block-elements/" target="_blank">ссылке</a> </strong>ознакомьтесь с особенностями inline-block элементов, в частности, почему у них всегда есть странный отступ.</p></div></section><!-- SECTION --><section id="margin"><h2>Особенности margin</h2><p>Итак, margin, внешний отступ блока, используется для визуальной реализации вертикальных\горизонтальных зазоров между блоками. Может быть у всех элементов, кроме строчных, которым можно задать только горизонтальный margin.</p><h3>Схлопывание вертикальных отступов</h3><p>Одно из самых важных правил, которые нужно запомнить. Соприкасающиеся вертикальные отступы margin объединяются. При этом ширина общего отступа равна ширине большего из исходных отступов. Слияние выполняется только для блочных элементов в нормальном потоке документа.</p><p>Дадим верхнему блоку margin-bottom в 30px, нижнему блоку margin-top в 50px, результирующий margin будет не 80px, из-за схлопывания вертикальных отступов, будет выбран больший - 50px.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_prVLoy" src="./Модуль 3_files/prVLoy.html" scrolling="no" frameborder="0" height="325" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-margin-collapse" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>Выпадение вертикальных отступов</h3><p>Если внутри одного блока расположить другой блок и задать ему margin-top, то внутренний блок прижмется к верхнему краю родительского, а у родительского элемента появится отступ сверху, т.е. внутренний блок «выпадет» из родительского блока. Если у родительского элемента также был задан верхний отступ, то выберется наибольшее из значений.</p><p>В примере мы задали margin-top в 50px для inner-box, а в результате отодвинулся не он сам от верха outer-box, а весь outer-box.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_JyvLYp" src="./Модуль 3_files/JyvLYp.html" scrolling="no" frameborder="0" height="318" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-margin-pierce" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p>Верхний margin на стыке с блоком-родителем как будто пробивает его и вылазит наружу, это одна из самых частых ошибок при верстке! Рекомендуем никогда не использовать верхний и нижний margin для блока-ребенка, если он вложен в блок-родитель, и необходимо отодвинуть ребенка внутрь родителя, используйте для этого padding родителя!</p></div></section><!-- SECTION --><section id="align"><h2>Горизонтальное и вертикальное выравнивание</h2><p>В этой секции мы познакомимся с базовыми приемами выравнивания блочного и строчного контента внутри блока-родителя.</p><h3>Горизонтальное</h3><br><!-- subsection --><h4>text-align</h4><p>Свойство <code>text-align</code> используется для выравнивания строки текста или строчных и строчно-блочных элементов внутри блочного элемента по ширине относительно его границ. Применяется только к блочным элементам, например, абзацам. Наследуется.</p><p>Возможные значения: <code>left|right|center|justify|inherit|initial</code>.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_prVVbL" src="./Модуль 3_files/prVVbL.html" scrolling="no" frameborder="0" height="214" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-text-align" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h4>margin</h4><p>Блочный элемент можно выровнять внутри родителя, задав ему горизонтальный margin. Центрировать можно, указав для <code>margin-left</code> и <code>margin-right</code> значение <code>auto</code> (а также прописав для него конкретный <code>width</code>, иначе он займёт всю ширину родительского контейнера, и не будет нуждаться в центрировании). Прижать к правому краю родителя можно задав ему <code>margin-left: auto</code>.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_YxLLxw" src="./Модуль 3_files/YxLLxw.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-margin-auto" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Вертикальное</h3><br><h4>Vertical-align</h4><p>Применяется только к строчным и строчно-блочным элементам, не выравнивает содержимое блочного элемента, не наследуется. Отлично подходит если стоит задача выровнять элементы в одной строке по вертикали.</p><div class="note"><p>В таблице приведены самые часто используемые значния свойства <code>vertical-align</code>, полный список значений есть по ссылкам в дополнительных материалах.</p></div><table><tbody><tr><th>Значение</th><th>Описание</th></tr><tr><td>top</td><td>Верхний край элемента совмещается с верхним краем самого высокого элемента в линии.</td></tr><tr><td>middle</td><td>Средняя линия элемента (обычно изображения) совмещается с линией, проходящей через середину родительского элемента.</td></tr><tr><td>bottom</td><td>Нижний край элемента совмещается с нижним краем самого низкого элемента в линии.</td></tr><tr><td>super</td><td>Выравнивает элемент так, как если бы он был надстрочным.</td></tr><tr><td>sub</td><td>Выравнивает элемент так, как если бы он был подстрочным.</td></tr></tbody></table><div class="cp_embed_wrapper"><iframe id="cp_embed_mMLLYM" src="./Модуль 3_files/mMLLYM.html" scrolling="no" frameborder="0" height="426" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-3-vertical-align" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section><!-- SECTION --><section id="styling-text"><h2>Оформление текста</h2><p>Частой задачей при верстке является стилизация текстового контента, поэтому рассмотрим полезные свойства для оформления текста и их значения. Они могут быть применены к любому элементу, который содержит текстовый контент.</p><table><tbody><tr><th>Свойство</th><th>Описание</th></tr><tr><td>font-size</td><td>указывает размер шрифта</td></tr><tr><td>font-weight</td><td>указывает "вес" (жирность начертания) шрифта</td></tr><tr><td>font-style</td><td>указывает стиль начертания шрифта</td></tr><tr><td>font-family</td><td>указывает семейство шрифтов</td></tr><tr><td>text-decoration</td><td>указывает декорирование шрифта</td></tr><tr><td>color</td><td>указывает цвет текста</td></tr><tr><td>text-indent</td><td>указывает отступ первой строки в абзаце</td></tr><tr><td>line-height</td><td>управляет межстрочным интервалом — дополнительным расстоянием между строками над и под текстом. При равных значениях line-height и height выравнивает текст по высоте.</td></tr></tbody></table><div class="cp_embed_wrapper"><iframe id="cp_embed_zdZppQ" src="./Модуль 3_files/zdZppQ.html" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="module-3-example-text" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section><!-- SECTION --><section id="background"><h2>Фон</h2><p>Фон в визуальном послании - будь это журнал, картина или веб-страница, всегда преследует две цели. Первая цель - это помощь в распознавании, выделении контента. Если текст светлый, то фон должен быть темным (и наоборот). В противном случае чтение становится трудным или невозможным. Вторая цель использования фона - это помощь в восприятии смысла, подсказка о содержимом контента. Текст с названием компании на фоне пальм и морского пляжа без лишних слов подскажет сферу деятельности и поможет принять решение о том, продолжать ли знакомство с контентом.</p><p>В браузере для работы с фоном используется свойство CSS <code>background</code> (и ряд других свойств, начинающихся с этого слова). Этих свойств не много, но они отличаются особой моделью поведения и правилами расчета положения на экране.</p><!-- SUB SECTION --><h3>Фон родителя и потомков. Фон по умолчанию. Наследование.</h3><p>Если элемент находится в потоке документа (а это происходит по умолчанию со всеми элементами), то фон потомка будет над фоном родительского элемента. <img src="./Модуль 3_files/background-mutylyer.png" alt="background mutylyer"> По умолчанию все элементы имеют белый цвет фона, и свойство <code>background</code> не наследуется. Это означает, что если фон отличается от белого, то его всегда нужно задавать.</p><div class="note"><p>Фон для элементов, в том числе <code>body</code>, связан с их высотой. По умолчанию высота этих элементов <code>auto</code>, т.е. определяется контентом. Для того чтобы заполнить экран фоном полностью, и при этом не зависеть от количества контента, потребуется установить для <code>body</code> свойство <code>min-height: 100vh</code>. Таким образом высота <code>body</code> будет минимум по высоте вьюпорта, или больше если того потребует контент.</p></div><p>Существует возможность сделать цвет фона прозрачным или полупрозрачным. Это создает т.н. новый контекст, т.е. вынуждает браузер учитывать дополнительные факторы при рендеринге страницы - цвет фона, border, padding и контента, находящегося под таким фоном. Это усложняет расчеты и требует дополнительных ресурсов устройства, заставляет разработчика тратить больше времени на создание страницы и проверку отображения. Поэтому если есть выбор, то стоит рассмотреть альтернативный вариант верстки.</p><!-- SUB SECTION --><h3>Свойство background</h3><p>Это краткая запись, которая допускает описание до 5 различных свойств фона одновременно. Рассмотрим пример этой краткой записи и затем перейдем к знакомству с этими свойствами в полной записи.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_dzmvpM" src="./Модуль 3_files/dzmvpM.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="background-size" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><table><tbody><tr><th>Свойство</th><th>Описание</th></tr><tr><td>background-color</td><td>задает цвет фону, либо делает фон прозрачным с помощью специального значения <code>transparent</code></td></tr><tr><td>background-image</td><td>позволяет задать фону изображение по url. Через запятую можно задать несколько изображений. Слой image находится над color, т.е. если размер изображения меньше или изображение не загрузится, то будет виден цвет фона, заданный background-color</td></tr><tr><td>background-repeat</td><td>по умолчанию заполняет фон копиями background-image. Возможно запретить повторение или задать направление (горизонталь, вертикаль) для повторения.</td></tr><tr><td>background-position</td><td>задает положение изображения относительно границ блока. В качестве значения этого свойства используют абсолютные(px), относительные единицы(%) и ключевые слова (top, right).</td></tr><tr><td>background-attachment</td><td>определяет поведение фонового изображения при прокрутке содержимого с помощью scroll</td></tr><tr><td>background-size</td><td>определяет размеры фонового изображения в контейнере, использует абсолютные(px), относительные единицы(%) и ключевые слова (cover, contain)</td></tr><tr><td>background-clip</td><td>Изменяет границу распространения фона для box-model. Обрезает фон до заданной области. По умолчанию фон включает content-area, padding и border. Можно уменьшить, вплоть до content-area.</td></tr><tr><td>background-origin</td><td>Изменяет границу распространения фона для box-model. Изменяет размер фона до заданной области. По умолчанию фон включает content-area, padding и border. Можно уменьшить, вплоть до content-area.</td></tr></tbody></table><!-- SUB SECTION --><h4>background-repeat</h4><p>Пример применения значений <code>no-repeat</code>, <code>repeat-x</code>, <code>repeat-y</code> и <code>repeat</code> (по умолчанию).</p><div class="cp_embed_wrapper"><iframe id="cp_embed_qXoVbJ" src="./Модуль 3_files/qXoVbJ.html" scrolling="no" frameborder="0" height="500" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="background-repeat" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- SUB SECTION --><h4>background-position</h4><p>Имеет два значения, первое описывает горизонтальное положение, а второе вертикальное. Если используется только одно значение, то это означает что второе по умолчанию <code>center</code> (или 50%).</p><p>Обратите внимание, что в отличие от <code>box-model</code> разместить фон по центру блока достаточно легко - достаточно задать 50% по вертикали и горизонтали. Это возможно из-за того, что проценты применяются к точке отсчета, которая в свою очередь также смещается на те же проценты по площади изображения. Легче всего разобраться с этим на примере (точка отсчета - белый круг, а фоновое изображение - красный квадрат).</p><div class="cp_embed_wrapper"><iframe id="cp_embed_vJRzYL" src="./Модуль 3_files/vJRzYL.html" scrolling="no" frameborder="0" height="460" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="background-position" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- SUB SECTION --><h4>background-size</h4><p>У этого правила наибольшее количество значений. Но наиболее важно понимать, как работают два из них - <code>cover</code> и <code>contain</code>. Оба эти свойства стремятся вместить в контейнер фоновое изображение по максимуму, только одно за счет обрезания лишнего, а другое за счет появления пустого пространства в контейнере - см. рисунок. <img src="./Модуль 3_files/cover-and-contain.jpg" alt="cover и contain"> Можно задавать числовые значения. Если будет задано одно значение, то браузер будет считать его шириной фона и высоту вычислит сам, сохраняя пропорции. Если будет задано два значения - то первое будет как всегда отвечать за горизонталь, т.е. это будет ширина, а второе - высота. И самое интересное, если фону было задано несколько изображений, то также, через запятую, можно задать несколько наборов размеров для этих изображений. Пример.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_MvVRBR" src="./Модуль 3_files/MvVRBR.html" scrolling="no" frameborder="0" height="470" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="background-size" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- SUB SECTION --><h4>background-attachment</h4><p>Пример применения значений <code>local</code>, <code>fixed</code> и <code>scroll</code> (по умолчанию). Различие в поведении проявляется при прокрутке содержимого блока - фон либо привязан к содержимому, либо зафиксирован относительно границ страницы, либо зафиксирован относительно границ блока.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_YxaQgX" src="./Модуль 3_files/YxaQgX.html" scrolling="no" frameborder="0" height="450" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="background-attacment" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- SUB SECTION --><h3>Параллакс-эффект на CSS</h3><p>Параллакс(Parallax, греч. смена, чередование) – это изменение видимого положения объекта по отношению к удаленному фону в зависимости от нахождения наблюдателя. Первостепенно этот термин употреблялся для природных явлений, в астрономии и геодезии.</p><p>В веб-дизайне параллакс-эффект или параллакс-скроллинг – это специальная техника, когда фоновое изображение в перспективе двигается медленнее, чем элементы переднего плана. Эта технология применяется все чаще, так как выглядит действительно эффектно. Достигается такой эффект трехмерного пространства с помощью нескольких слоев, которые накладываются друг на друга и при прокручивании движутся с различной скоростью.</p><p>Основной минус параллакса – это проблемы с производительностью сайта. Выглядит все красиво и стильно, но применение JavaScript, с помощью которого и создается эффект параллакса, в значительной степени утяжеляет страницу и очень снижает скорость ее загрузки. Это происходит потому, что в его основе лежат сложные вычисления: JavaScript приходится контролировать положение каждого пикселя на экране.</p><p>С появлением CSS3 задача немного упростилась. С его помощью можно создать очень похожий эффект, который будет намного экономичнее в плане ресурсозатрат.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_rpJpWV" src="./Модуль 3_files/rpJpWV.html" scrolling="no" frameborder="0" height="600" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="module-03-css-parallax" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p>Ближе к концу курса вернитесь и ознакомьтесь со статьей <a href="https://keithclark.co.uk/articles/pure-css-parallax-websites/" target="_blank" rel="noopener">Pure CSS Parallax Websites</a>, где в деталях описано создание сложного параллакса на чистом CSS.</p></section><!-- SECTION --><section id="resources"><h2>Дополнительные материалы</h2><ul><li><a href="https://github.com/web-standards-ru/dictionary/blob/master/dictionary.md" target="_blank">Словарь терминов</a></li><li><a href="http://learn.shayhowe.com/html-css/getting-to-know-css/" target="_blank">Хорошая статья о азах CSS</a></li><li><a href="https://github.com/yoksel/common-words" target="_blank">Словарь имен CSS классов</a></li><li><a href="https://code.tutsplus.com/ru/tutorials/the-30-css-selectors-you-must-memorize--net-16048" target="_blank">CSS селекторы</a></li><li><a href="https://jigsaw.w3.org/css-validator/" target="_blank">CSS валидатор</a></li><li><a href="http://learnlayout.com/inline-block.html" target="_blank">Учим inline-block</a></li><li><a href="http://christopheraue.net/2014/03/05/vertical-align/" target="_blank">Все о vertical-align</a></li><li><a href="https://css-tricks.com/almanac/" target="_blank">CSS альманах</a></li><li><a href="https://docs.emmet.io/cheat-sheet/" target="_blank">Cheat sheet для Emmet</a></li><li><a href="https://css-tricks.com/almanac/properties/b/background-size/" target="_blank">CSS-tricks background-size</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin" target="_blank">MDN background-origin</a></li></ul></section></article><!-- ===== #page-navigator ======  --> <a href="http://fecore.net.ua/theory/module-3.html#main-nav" class="to-page-nav"></a><!-- ===== #end page-navigator =====  --></div></body></html>
<!DOCTYPE html>
<!-- saved from url=(0041)http://fecore.net.ua/theory/module-2.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,maximum-scale=1,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Модуль 2</title><link rel="stylesheet" href="./Модуль 2_files/styles.min.css"></head><body><div class="wrapper"><article><header><h1>Модуль 2 - Теория</h1><!-- ===== page-navigator =====  --><section class="table-of-contents" id="main-nav"><h2>Содержание</h2><ol class="page-nav"><li><a href="http://fecore.net.ua/theory/module-2.html#entry">Введение</a></li><li><a href="http://fecore.net.ua/theory/module-2.html#git-sections">Секции Git проекта</a></li><li><a href="http://fecore.net.ua/theory/module-2.html#git-state">Состояния Git</a></li><li><a href="http://fecore.net.ua/theory/module-2.html#git-basics">Основы Git</a></li><li><a href="http://fecore.net.ua/theory/module-2.html#git-work">Процесс работы с Git-проектом</a></li><li><a href="http://fecore.net.ua/theory/module-2.html#git-console">Работа с Git из консоли</a></li><li><a href="http://fecore.net.ua/theory/module-2.html#gitignore">Файл .gitignore</a></li><li><a href="http://fecore.net.ua/theory/module-2.html#resources">Дополнительные материалы</a></li></ol></section><!-- ====== end page-navigator =====  --></header><!-- SECTION --><section id="entry"><h2>Введение</h2><p>Когда проект достаточно большой или над проектом работает не один специалист, а группа, то возникает вопрос - где и как хранить код, как получать из хранилища самую актуальную версию, и как отыскать старую версию, если она вдруг понадобиться. Именно для решения этих вопросов (а также множество других, не менее важных) существуют системы контроля версий. Данные системы позволяют нескольким разработчикам параллельно работать над одним проектом, обеспечивая, при этом, гарантию того, что не один из разработчиков не удалит код другого.</p><p><strong>Система контроля версий</strong> — это программа, позволяющая разработчикам проекта отслеживать и записывать изменения, вносимые всеми участниками в файлы этого проекта. Результат может быть объединен в один файл или разбит на множество файлов - все равно вклад каждого участника, история его записей будет сохранена. На сегодня одной из самых распространенных систем контроля версий является Git.</p><p>Так как данный курс берет на себя задачу обучения верстке, git является вспомогательным инструментом для автоматизации и удобства процесса сдачи домашних заданий. Мы рассмотрим ключевые моменты и понятия Git достаточные для удобной работы с курсом.</p><div class="note"><p>Рекомендуем ознакомиться с исчерпывающим <a href="https://www.atlassian.com/git/tutorials/what-is-version-control" target="_blank">учебником по Git от Atlassian</a> в свободное от курса время. Также в дополнительных материалах есть видеокурс по <code>git</code> на русском.</p></div><!-- subsection --><h3>Git</h3><p><strong><a href="https://git-scm.com/" target="_blank">Git (Гит)</a> </strong>— система контроля и управления версиями файлов. Технология организации системы контроля версий достаточно специфична и в чем-то отдаленно похожа на хранение файлов на сервисе <code>Google Drive</code> с тем отличием, что все изменения и версии файлов фиксируются, и для работы используется специальная программа или терминал.</p><!-- subsection --><h3>GitHub</h3><p><strong><a href="https://github.com/" target="_blank">GitHub (Гитхаб)</a> </strong>— веб-сервис для размещения репозиториев и совместной разработки проектов. Работает по принципам Git и является хостингом IT-проектов. Предоставляет весь необходимый функционал для работы Git. Существуют и другие подобные сервисы, например - GitLab и BitBucket.</p><!-- subsection --><h3>Репозиторий</h3><p><strong>Репозиторий (Repository)</strong> - каталог файловой системы, в котором находятся: файлы конфигурации, файлы журналов операций выполняемых в репозитории, индекс расположения файлов и хранилище, содержащее сами контролируемые версии файлов.</p><h4>Типы репозиториев</h4><ul><li><code>Локальный репозиторий</code> - репозиторий, расположенный на локальном компьютере разработчика в каталоге. Именно в нём происходит разработка и фиксация изменений, которые отправляются на удалённый репозиторий.</li><li><code>Удалённый репозиторий</code> — репозиторий, находящийся на удалённом сервере. Это общий репозиторий, в который приходят все изменения и из которого забираются все обновления. Предоставляет возможность совместной работы над проектом.</li></ul></section><!-- SECTION --><section id="git-sections"><h2>Секции Git-проекта</h2><ul><li><code>Рабочая директория (working directory)</code> - является снимком версии проекта. Файлы распаковываются из сжатой базы данных в Git-директории и располагаются на диске, для того чтобы их можно было изменять и использовать.</li><li><code>Область подготовленных файлов (staging area)</code> - это файл, располагающийся в вашей Git-директории, в нём содержится информация о том, какие изменения попадут в следующий коммит. Эту область ещё называют “индекс”, однако называть её <code>stage</code> также общепринято.</li><li><code>Git-директория (git directory)</code> - это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git, и это та часть, которая копируется при клонировании репозитория с другого компьютера.</li></ul><img src="./Модуль 2_files/module-2-git-states.png" alt=""></section><!-- SECTION --><section id="git-state"><h2>Состояния Git</h2><p>Состояния Git это ключевое понятие, которое нужно усвоить. Git имеет три основных состояния, в которых могут находиться файлы:</p><ul><li><code>Зафиксированном (committed)</code> - значит, что файл уже сохранён в вашем локальном репозитории</li><li><code>Изменённом (modified)</code> - файлы, которые поменялись, но ещё не были зафиксированы</li><li><code>Подготовленном (staged)</code> - это изменённые файлы, отмеченные для включения в следующий коммит</li></ul><img src="./Модуль 2_files/module-2-git-file-life.png" alt=""></section><section><h2 id="git-basics">Основы Git</h2><!-- subsection --><h3>Клонирование</h3><p><strong>Клонирование (Clone)</strong> — скачивание репозитория с удалённого сервера на локальный компьютер в определённый каталог для дальнейшей работы с этим каталогом как с репозиторием.</p><p>В процессе клонирования удаленного репозитория, на локальном компьютере появится папка (имя папки соответствует имени репозитория), в которой будут находиться все файлы репозитория, и происходит связывание локальной папки и удаленного репозитория. Так же в ней появляется скрытая папка <code>.git</code>, которая и есть локальным репозиторием, это служебная папка Git.</p><p>В результате клонирования, разработчик может работать с файлами проекта: изменять их, удалять или создавать новые. Эти изменения - локальные. В конце определенного этапа работы разработчик должен сделать коммит, т.е. зафиксировать произведенные изменения. То, после каких этапов работы делать коммиты, разработчик выбирает сам (это может быть конец разработки определенного элемента или просто окончание рабочего дня).</p><div class="note"><p>При клонировании не происходит копирования только рабочей копии. Git получает копию практически всех данных, которые есть на удаленном сервере. При выполнении операции клонирования с сервера забирается каждая версия каждого файла из истории проекта.</p></div><!-- subsection --><h3>Коммит</h3><p><strong>Коммит (Commit)</strong> — создание нового снимка состояния файлов проекта, фиксация изменений и запись изменений в локальный репозиторий. Коммит является минимальной структурной составляющей разработки, все коммиты хранятся в системе контроля версий, и разработчик может вернуться (откатить проект) к любому коммиту за всё время разработки.</p><div class="note"><p>Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён.</p></div><!-- subsection --><h3>Пуш</h3><p><strong>Пуш (Push)</strong> — отправка всех новых коммитов на удалённый репозиторий.</p><p>Когда вы хотите добавить свои локальные наработки на удаленный репозиторий, необходимо сделать пуш (push). Эта операция срабатывает только в случае совпадения 2-х условий:</p><ul><li>если вы клонировали репозиторий с сервера, на котором у вас есть права на запись</li><li>и если никто другой с тех пор не выполнял команду push</li></ul><div class="note"><p>Если после того как вы произвели клонирование кто-то с правом на запись выполнил команду push, то ваш push точно будет отклонён. Чтобы команда push сработала, потребуется получить изменения ( команда pull), а затем полученные изменения объединить с вашими (merge). Это релевантно только при командной разработке, если вы единственный участник процесса разработки, таких ситуаций не будет.</p></div><!-- subsection --><h3>Пул</h3><p><strong>Пул (Pull)</strong> — получение последних изменений с удалённого репозитория.</p><p>Git автоматически извлекает и затем сливает данные из удалённой ветки в вашу текущую ветку. К тому же по умолчанию операция клонированая автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали (подразумевается, что на удалённом сервере есть ветка master). Выполнение пула, как правило, извлекает данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.</p><!-- subsection --><h3>Ветки</h3><p><strong>Ветка (Branch)</strong> — это параллельная версия репозитория. Она включена в этот репозиторий, но не влияет на главную версию, тем самым позволяя свободно работать в параллельной. Когда вы внесли нужные изменения, то вы можете объединить их с главной версией.</p><p>Над проектом обычно работает не один человек. Разработка заключается в написании определенного модуля, исправлении некоторой ошибки, либо любой другой активности, которая требует автономности. Для этого и используются ветки. Имя ветки чаще всего выбирается по названию модуля или исправления.</p><h4>Процесс использования ветки</h4><ul><li>В начале работы над исправлениями или новыми модулями разработчик создает новую ветку из главной.</li><li>В процессе работы по необходимости (при завершении определенной части работы), разработчик делает коммиты в созданную ветку.</li><li>После окончания работы с веткой (полностью разработан новый модуль или исправлена ошибка), разработчик делает слияние созданной ветки с главной.</li><li>Если в дальнейшем работать с веткой не планируется, она удаляется. Если во время работы с новой веткой никто из разработчиков, работающих с данным проектом, на изменял файлы, которые были изменены в процессе работы с новой веткой, то слияние происходит. В противном случае возникают конфликты, которые необходимо разрешить (о конфликтах позже).</li></ul><div class="note"><p>В процессе разработки есть возможность переключаться между ветками. При этом в локальной папке, связанной с репозиторием, будет отображаться та версия файлов, которая соответствует текущей ветке</p></div><h4>Мастер</h4><p><strong>Мастер (Master)</strong> — главная или основная ветка репозитория. Создается по умолчанию в момент создания репозитория.</p><h4>Мёрдж</h4><p><strong>Мёрдж (Merge)</strong> — слияние изменений из какой-либо ветки репозитория с любой веткой этого же репозитория. Чаще всего это слияние ветки с изменениями с основной веткой репозитория.</p><!-- subsection --><h3>Конфликт</h3><p>В некоторых случаях, при слиянии текущей ветки и главной (master), могут возникать конфликты. Причина их возникновения всегда одна - определенные файлы, с которыми велась работа в созданной ветке, параллельно были изменены и в мастере. И теперь, при слиянии, нет однозначного варианта сшития контента файлов, который бы не повлек потерю данных. В этом случае разработчику необходимо определить, какие изменения должны быть оставлены, а какие отброшены.</p><h4>Разрешение конфликтов</h4><p>Разрешение конфликта заключается в том, что на основе двух версий файлов (той, которая уже лежит в мастере и той, которую вы собираетесь туда положить) нужно сформировать итоговый файл.</p><!-- subsection --><h3>Форк</h3><p><strong>Форк (Fork)</strong> — копия репозитория. Его также можно рассматривать как внешнюю ветку для текущего репозитория. Копия вашего открытого репозитория на Гитхабе может быть сделана любым пользователем, после чего он может прислать изменения в ваш репозиторий через пулреквест.</p><!-- subsection --><h3>Пулреквест</h3><p><strong>Пулреквест (Pull Request)</strong> — запрос на слияние форка репозитория с основным репозиторием. Пулреквест может быть принят или отклонён вами, как владельцем репозитория.</p></section><!-- SECTION --><section id="git-work"><h2>Процесс работы с Git-проектом</h2><ol><li>Для нового проекта создается удаленный репозиторий и клонируется на локальную машину. У вас появляется точная копия удаленного репозитория, которая автоматически с ним связывается. Или создается локальная папка с проектом, после чего она связывается с удаленным репозиторием.</li><li>Далее идет работа в мастере или в ветках.</li><li>Вы изменяете файлы в вашей рабочей директории.</li><li>Вы добавляете файлы в индекс, добавляя тем самым их снимки в область подготовленных файлов.</li><li>Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в вашу Git-директорию.</li><li>Если вы работаете сами, в ветке, то перед тем как делать пуш необходимо смерджить ветку в локальный мастер. Если же разработчиков много, процесс работы с ветками несколько усложняется.</li><li>Делается пуш для обновления удаленного репозитория.</li></ol></section><!-- SECTION --><section id="git-console"><h2>Работа с Git из консоли</h2><p>С Git можно работать не только из программ с графическим интерфейсом, но и из консоли. В веб-разработке понимание Git и умение работы с Git из консоли чаще всего является требованием.</p><p>Таблица базовых команд для работы с git из консоли, при условии что git есть в системе.</p><table><thead><tr><th>Синтаксис</th><th>Описание</th></tr></thead><tbody><tr><td><code>git clone [params]</code></td><td>Клонирует удаленный репозиторий на компьютер автоматически связывая его с локальной версией.</td></tr><tr><td><code>git status</code></td><td>Проверяет наличие изменений в состоянии файлов проекта со времени последнего коммита. При наличии изменений выведет в консоль информацию о файлах в которых есть изменения.</td></tr><tr><td><code>git add [file-name или .]</code></td><td>Чтобы сообщить Git о необходимости начать отслеживать изменения, внесенные в файлы, сначала нужно добавить их в <code>staging area</code>, используя <code>git add</code>. При выполнении <code>git add .</code> точка обозначает добавление всех изменений которые есть.</td></tr><tr><td><code>git reset [filename]</code></td><td>Используется для удаления файла из под версионного контроля.</td></tr><tr><td><code>git commit -m "комментарий"</code></td><td>Создает слепок текущего состояния файлов которые находятся под версионным контролем. Принято описывать каждый commit кратким ясным комментарием о внесенных изменениях. Количество коммитов не ограничено. Таким образом, если нам когда-либо понадобится вернуться к прошлой версии проекта, мы сможем откатить проект до определенного коммита.</td></tr><tr><td><code>git log</code></td><td>Выводит журнал изменений в репозитории, как список всех коммитов которые были сделаны, в хронологическом порядке.</td></tr><tr><td><code>git push</code></td><td>Отправляет все сохраненные в коммитах изменения из локального репозитория на удаленный. При выполнении <code>git push -u origin master</code>, флаг <code>-u</code> говорит Git запомнить куда мы пушим (на удаленный репозиторий, <code>origin</code>, в ветку <code>master</code>). После чего достаточно будет выполнять просто <code>git push</code>.</td></tr><tr><td><code>git pull</code></td><td>Забирает последние изменения с удаленного репозитория в локальный, при условии что они уже связаны.</td></tr><tr><td><code>git init</code></td><td>Инициализирует создание локального репозитория в текущей папке. Создается скрытая папка <code>.git</code> в которой хранится служебная информация о локальном репозитории.</td></tr><tr><td><code>git remote add origin [repo-url]</code></td><td>Связывает удаленный репозиторий с локальным репозиторием по <code>url</code>. Нужен существующий удаленный репозиторий. После выполнения комманды можно будет пушить изменения на удаленный репозиторий.</td></tr></tbody></table></section><!-- SECTION --><section id="gitignore"><h2>Файл .gitignore</h2><p>Если создать файл .gitignore в своем репозитории, Git использует его, чтобы определить, какие файлы и каталоги (или целые шаблоны) игнорировать, прежде чем совершать коммит. Обычно он используется, чтобы избежать передачи временных файлов из вашего рабочего каталога, которые не являются полезными для других соавторов, таких как продукты компиляции, файлы настроек проекта, созданные средой разработки и т.д.</p><div class="note"><p><code>.gitignore</code> это не расширение файла, а его имя. В проводнике windows создать такой файл не получится, возьмите <code>.gitignore</code> с вебинара или создайте его при инициализации вашего репозитория для домашних работ.</p></div><!-- subsection --><h3>Правила синтаксиса в .gitignore</h3><ul><li>Одна строчка - одно правило</li><li>Пустые строки игнорируются</li><li>Комментарии доступны через решётку(#) в начале строки</li><li>Символ "/" в начале строки указывает, что правило применяется только к файлам и папкам, которые располагаются в той же папке, что и сам файл .gitignore</li><li>Можно использовать спецсимволы: звёздочка(*) заменяет любое количество символов(ноль или больше), вопрос(?) заменяет от нуля до одного символа. Спецсимволы можно размещать в любом месте правила</li><li>Две звёздочки(**) используются для указания любого количества поддиректорий, подробнее смотри ниже в примерах</li><li>Восклицательный знак(!) в начале строки означает инвертирование правила, необходим для указания исключений из правил игнорирования</li><li>Символ "\" используется для экранирования спецсимволов, например, чтобы игнорировать файл с именем "!readme!.txt", нужно написать такое правило: "\!readme!.txt"</li><li>Для игнорирования всей директории, правило должно оканчиваться на слэш(/), в противном случае правило считается именем файла</li></ul><!-- subsection --><h3>Пример записи файла .gitignore</h3><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em"><pre style="margin: 0; line-height: 125%"># Игнор-лист файлов проекта
# Игнорировать ВСЕ файлы и директории, включая поддиректории и файлы в них
*

# ---- ФАЙЛЫ ----
# Игнорирование по типу файла, будут игнорироваться в АБСОЛЮТНО всех директориях
# Например /files/data.zip, /server.log, /uploads/users/data/info.xls
*.zip
*.log
*.pdf
*.xls

# Игнорирование файла во ВСЕХ директориях
# Например /params/db/config.php, /config.php
config.php

# Игнорирование конкретного файла ТОЛЬКО в корне проекта
# (корнём считается расположение файла .gitignore)
# Например НЕ БУДЕТ проигнорирован файл /db/config.php
/config.php

# Игнорирование конкретного файла ТОЛЬКО в указанной директории
# Например НЕ БУДЕТ проигнорирован файл /prod/params/config.php
/params/config.php

# ---- ДИРЕКТОРИИ ----
# Игнорирование всех файлов и папок ТОЛЬКО в конкретной директории(включая поддиректории и файлы в них)
# Например /images/user.jpg, /images/company/logo.png
# НЕ БУДУТ проигнорированы файлы и папки /prod/images/user.jpg
/images/*

# Игнорирование всех файлов и папок в ЛЮБЫХ директориях с указанным именем
# Например /images/user.jpg, /core/images/user.jpg
images/*

# Игнорирование ВСЕХ html-файлов в ОДНОЙ КОНКРЕТНОЙ директории(НЕ ВКЛЮЧАЯ поддиректории)
# Например /private/index.html
# НЕ БУДУТ проигнорированы файлы в /private/ivan/index.html
/private/*.html

# Игнорирование ВСЕХ html-файлов в КОНКРЕТНОЙ директории ВКЛЮЧАЯ поддиректории
# Например /private/info.html, /private/users/ivan/info.html
/private/**/*.html

# ---- РАЗНОЕ ----
# Исключение из игнорирования
# Игнорирование ВСЕХ файлов и папок внутри директории /secret,
# за исключением файла /secret/free.txt, он не будет проигнорирован
/secret/*
!/secret/free.txt

# Игнорирование файла с именем, содержащим спецсимволы
# Например !readme!.txt
\!readme!.txt

# Игнорирование всех JPG и JPEG файлов внутри директорий,
# которые начинаются на "h" и МОГУТ содержать ещё один символ после
# Например /images/h4/user.jpg, /images/h/company.jpeg
/images/h?/*.jp?g
</pre></div></section><!-- SECTION --><section id="resources"><h2>Дополнительные материалы</h2><ul><li><a href="https://youtu.be/GyI0T2U_vO8?list=PLpY_9m7gHQDibfa9MJfnEQd2UWI5gztp8" target="_blank">Видеокурс по работе с Git из консоли</a></li><li><a href="https://www.atlassian.com/git/tutorials/what-is-version-control" target="_blank">Книга по Git от atlassian.com</a></li><li><a href="https://git-scm.com/book/ru/v2" target="_blank">Официальная документация/книга по Git</a></li></ul></section></article><!-- ===== #page-navigator ======  --> <a href="http://fecore.net.ua/theory/module-2.html#main-nav" class="to-page-nav"></a><!-- ===== #end page-navigator =====  --></div></body></html>
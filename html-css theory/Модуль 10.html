<!DOCTYPE html>
<!-- saved from url=(0042)http://fecore.net.ua/theory/module-10.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,maximum-scale=1,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Модуль 10</title><link rel="stylesheet" href="./Модуль 10_files/styles.min.css"><script async="" src="./Модуль 10_files/ei.js.Без названия"></script><script async="" src="./Модуль 10_files/prism.js.Без названия"></script></head><body><div class="wrapper"><article><header><h1>Модуль 10 - Теория</h1><!-- ===== page-navigator =====  --><section class="table-of-contents" id="main-nav"><h2>Содержание</h2><ol class="page-nav"><li><a href="http://fecore.net.ua/theory/module-10.html#cross">Кроссбраузерность</a></li><li><a href="http://fecore.net.ua/theory/module-10.html#gd-pe">Graceful Degradation и Progressive Enhancement</a></li><li><a href="http://fecore.net.ua/theory/module-10.html#retina">Экраны высокой пиксельной плотности</a></li><li><a href="http://fecore.net.ua/theory/module-10.html#retina-res">Подготовка ресурсов для Retina</a></li><li><a href="http://fecore.net.ua/theory/module-10.html#svg">Основы работы с SVG</a></li><li><a href="http://fecore.net.ua/theory/module-10.html#bem">Методология BEM</a></li><li><a href="http://fecore.net.ua/theory/module-10.html#resources">Дополнительные материалы</a></li></ol></section><!-- ====== end page-navigator =====  --></header><!-- SECTION --><section id="cross"><h2>Кроссбраузерность</h2><p>В разных браузерах, так как они созданы разными компаниями и нет единого стандарта реализации css в браузере, отображение стилей тегов может отличаться. Так появилась необходимость в кроссбраузерости, чтобы образ веб сайта, задуманый дизайнером, выглядел одинаково.</p><p><strong>Кроссбраузерная верстка</strong> – верстка, нацеленная на создание сайта, отображаемого в каждом браузере одинаково корректно.</p><p>Есть подходы и правила, которых стоит придерживаться при разработке. При условии их использования, количество различий между отображением страницы в разных браузерах сводится к минимуму или исчезает совсем. Давайте рассмотрим их детальнее.</p><!-- subsection --><h3>Значение свойств по умолчанию</h3><p><strong>Свойства</strong> – это отступы, цвета, шрифты и т.д. В каждом браузере они могут быть разными. Все это должно быть описано в таблице стилей, в противном случае браузер будет самостоятельно проставлять значения, указанные по умолчанию. Поэтому в каждом из них сайт будет отображаться немного по разному. Частично решить эту проблему помогает использование:</p><ul><li><a href="http://cssreset.com/scripts/eric-meyer-reset-css/" target="_blank"><strong>reset.css</strong> </a>- полный сброс стилей в 0. Не рекомендуется к использованию "как есть" на реальных проектах. Можно считать это базой, на которой будет построены сбросы и настройки для проекта.</li><li><a href="https://necolas.github.io/normalize.css/" target="_blank"><strong>normalize.css</strong> </a>- это небольшой CSS-файл, который обеспечивает для HTML-элементов лучшую кроссбраузерность в стилях по умолчанию. Это современная, готовая к HTML5 альтернатива традиционному reset.css</li><li>CSS фреймворки, большинство включают свою версию normalize.css</li><li>или хотя бы минимальный сброс следующим css правилом: * { padding: 0; margin: 0; box-sizing: border-box; }</li></ul><!-- subsection --><h3>Валидность кода</h3><p>Не валидный код ведет к ошибкам отображения элементов страницы. Всегда проверяйте ваш HTML и CSS код валидаторами.</p><ul><li><a href="https://validator.w3.org/" target="_blank">HTML валидатор</a></li><li><a href="https://jigsaw.w3.org/css-validator/" target="_blank">CSS валидатор</a></li></ul><!-- subsection --><h3>Dry code</h3><p>Пишите dry (don't repeat yourself, сухой) код. Что это значит? Не используйте лишние css свойства, которые ничего не делают для вашего блока. Следите за тем, чтобы свойства не повторялись и не переопределяли друг друга в контексте одного css правила. Используйте минимальное количество кода для достижения цели.</p><!-- subsection --><h3>Инструменты разработчика</h3><p>Научитесь использовать плагины, позволяющие быстрее находить ошибки кода для каждого из браузеров.</p><ul><li><a href="https://developer.chrome.com/devtools" target="_blank">Chrome</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Tools" target="_blank">Firefox</a></li><li><a href="http://www.opera.com/dragonfly/" target="_blank">Opera</a></li><li><a href="https://docs.microsoft.com/en-us/microsoft-edge/f12-devtools-guide" target="_blank">Edge</a></li><li><a href="https://developer.apple.com/safari/tools/" target="_blank">Safari</a></li></ul><!-- subsection --><h3>Вендорные префиксы</h3><p>Вендорные префиксы - это приставки, используемые производителями (вендорами) браузеров для экспериментальных, еще не принятых в стандарт, CSS-свойств. Используйте инструменты для их автоматического добавления в код, к примеру, в начале можно пользоваться <a href="http://autoprefixer.github.io/" target="_blank">Автопрефиксером</a>.</p><p>Список вендорных префиксов:</p><ul><li>-webkit- (Chrome, Safari, новые версии Opera)</li><li>-moz- (Firefox)</li><li>-o- (Старые версии Opera)</li><li>-ms- (Internet Explorer)</li></ul><!-- subsection --><h3>Заключение</h3><p>Понимание причин некорректного отображения сайта, а так же навык кроссбраузерной верстки приходит со временем и в процессе долгой практики. Только методом проб и ошибок разработчик может разобраться какие браузеры, какие заморочки имеют. С опытом, верстальщик старается составить код, так, чтобы он был всячески адаптирован под каждый из браузеров, а в процессе верстки оставалось только подправить небольшие косяки.</p></section><!-- SECTION --><section id="gd-pe"><h2>Graceful Degradation и Progressive Enhancement</h2><p>В этой части мы кратко рассмотрим разницу между двумя подходами к созданию пользовательских интерфейсов: Изящная (постепенная) деградация и Прогрессивное (постепенное) улучшение.</p><!-- subsection --><h3>В чем разница?</h3><p><strong>Изящная деградация (Graceful Degradation)</strong> - практика создания веб-сайта, при которой он обеспечивает достойный уровень удобства пользователей в современных браузерах. Тем не менее, он будет деградировать изящно для тех, кто использует старые браузеры. Система может быть не такой приятной или красивой, но базовая функциональность будет работать на более старых системах. Как бонус, идет предоставление альтернативной версии функционала или информирование пользователя о недостатках продукта, в качестве меры безопасности, для обеспечения возможности использования продукта</p><p><strong>Прогрессивное улучшение (Progressive Enhancement)</strong> - это аналогичная концепция как при грациозной деградации, но наоборот. Разработка начинается с базового уровня полезной функциональности и пользовательского интерфейса для большинства браузеров. Расширенная функциональность будет добавлена, когда браузер ее поддерживает.</p><img src="./Модуль 10_files/pe-and-gd.png" alt=""><!-- subsection --><h3>Глубже в Progressive Enhancement</h3><p><strong>Прогрессивное улучшение</strong> - метод создания сайтов с прочным основанием, чтобы он был доступен для широкого круга ситуаций просмотра - от мобильных устройств и нетбуков до настольных компьютеров и скрин ридеров. В первую очередь это последовательное расширение HTML (представление), CSS (оформление) и JavaScript (функционал).</p><img src="./Модуль 10_files/pe-layers.png" alt=""><ul><li><strong>Представление (markup)</strong> - начинайте с семантического и хорошо структурированного HTML для гибкости и функциональной совместимости</li><li><strong>Оформление (styling)</strong> - постепенно улучшайте внешний вид дизайна, добавляя поддержку браузеров с большими возможностями</li><li><strong>Функционал (behaviour)</strong> - расширяйте сайт с помощью богатых интерактивных функций в веб-браузерах с помощью JavaScript</li></ul><p class="accent">К плюсам можно отнести:</p><ul><li><strong>Доступность</strong> - контент доступен всем посетителям</li><li><strong>Переносимость</strong> - поддержка большинства браузеров и устройств</li><li><strong>Модульность</strong> - наличие развязанных компонентов с явными границами упрощает и повышает отказоустойчивость сборки сайта</li><li><strong>Производительность</strong> - более легко реализуются улучшения с точки зрения (воспринимаемого) времени загрузки страницы (что влияет на удобство использования)</li></ul><p class="accent">Но есть и следующие минусы:</p><ul><li><strong>Время</strong> - требуется дополнительное время при разработке</li><li><strong>Исполнение</strong> - сложнее реализовать в больших многофункциональных приложениях, требует больше знаний и опыта разработки</li><li><strong>Зависимость</strong> - веб-приложениям с богатым функционалом требуются сценарии на стороне клиента</li></ul><!-- subsection --><h3>Пример</h3><p>Простым примером является использование 24-битных альфа-прозрачных PNG.</p><p>При GD эти изображения могут отображаться в современных браузерах без проблем. Более старые браузеры могут показывать изображение, но эффект прозрачности не сработает (при необходимости его можно заставить работать). Старые браузеры, которые не поддерживают PNG, будут отображать текст или пустое пространство.</p><p>При PE мы можем решить, что наше приложение должно функционировать во всех графических браузерах. Тогда изначально можно использовать изображения GIF более низкого качества по умолчанию, но заменять их 24-разрядными PNG, когда браузер их поддерживает.</p></section><!-- SECTION --><section id="retina"><h2>Экраны высокой пиксельной плотности</h2><p>В этой секции мы поговорим о разнице между обычным экраном и ретиной, а так же о терминах и приемах, которые используются при разработке для экранов высокой пиксельной плотности. Экран с высокой пиксельной плотностью на сегодняшний день не для кого не новость. Он есть в каждом смартфоне. В 2010 году, компания Apple представила iPhone с экраном Retina, который удвоил количество пикселей на дюйм. В результате этого релиза графика стала четче, чем мы когда-либо видели.</p><!-- subsection --><h3>Разрешение</h3><p><strong>Разрешение (resolution)</strong> - количество физических пикселей на экране устройства, обычно приводится нерешённым, что дополнительно говорит о соотношении сторон.</p><table><tbody><tr><th>разрешение</th><th>устройство</th></tr><tr><td>320 × 480</td><td>первый iPhone</td></tr><tr><td>1024 × 768</td><td>канонический десктоп</td></tr><tr><td>2880 × 1800</td><td>MacBook с ретиной</td></tr></tbody></table><!-- subsection --><h3>Плотность пикселей</h3><p><strong>Плотность пикселей (pixel density)</strong> - обозначает количество пикселей, которое помещается в один линейный дюйм. Измеряется в ppi (pixels per inch), относится к дисплеям, матрицам, сканерам.</p><img src="./Модуль 10_files/ppi-diff.png" alt=""><!-- subsection --><h3>Пиксели</h3><p>Есть несколько терминов, значение которых необходимо понимать:</p><ul><li><strong>Физический пиксель (physical pixel)</strong> - ячейка на матрице, единица разрешения дисплея устройства</li><li><strong>Виртуальный пиксель (device independent pixel, dip)</strong> - независимый от устройства пиксель, может быть больше, меньше или равен физическому</li><li><strong>Изменённый пиксель</strong> - появляется тогда, когда браузер или пользователь масштабируют изображение на экране</li></ul><img src="./Модуль 10_files/pixel-diff.png" alt=""><!-- subsection --><h3>Пиксельное соотношение</h3><p><strong>Пиксельное соотношение (pixel ratio)</strong> - отношение физического пикселя к виртуальному. Может меняться в зависимости от браузера.</p><p>Для лучшего понимания рассмотрим примеры:</p><ul><li><strong>Nexus One</strong>: разрешение 480 физических пикселей и 320 виртуальных, в итоге соотношение 1.5</li><li><strong>MacBook с ретиной</strong>: разрешение 2880 физических пикселей и 1440 виртуальных, в итоге соотношение 2.0</li></ul><!-- subsection --><h3>Retina</h3><p><strong>Retina</strong> - маркетинговый термин Apple, описывающий устройства с высоким разрешением и пиксельным соотношением больше чем 1. То есть виртуальный пиксель увеличивается по отношению к физическому. Все устройства Apple имеют соотношение 1 или 2. Другие планшеты и смартфоны имеют соотношение от 1,5 до 2,25.</p><img src="./Модуль 10_files/retina-example.png" alt=""></section><!-- SECTION --><section id="retina-res"><h2>Подготовка ресурсов для Retina</h2><p>Для экранов высокой пиксельной плотности (дальше просто Retina), необходимы специально подготовленные ресурсы. Текст отображается везде одинаково, так как его рендерит сам браузер, больше всего страдают изображения. Давайте научимся подготавливать изображения для Retina.</p><p>Самый простой способ подготовить графику к Retina-дисплею - это просто разделить пополам физические размеры изображения. Например, чтобы показать фотографию 200x300 пикселей на экране с увеличенной плотностью пикселов, необходимо загрузить фото размером 400x600 пикселей и уменьшить его, используя CSS</p><p>Следующий рисунок как нельзя лучше описывает процесс подготовки png\jpg и т.п. изображений для retina. Для каждого экрана мы экспортируем изображение x1, x2 и x3 размера от оригинала, сохраняем их с соответствующими префиксами @x2 @x3, для x1 (оригинала) префикс не нужен. После чего мы используем html или css для указания изображения.</p><img src="./Модуль 10_files/images-for-retina.png" alt=""><!-- subsection --><h3>Контентные изображения</h3><p>Мы уже знакомы с тегами picture и source. Для контентных изображений мы используем уже знакомую нам конструкцию srcset, где указываем пары url-картинки и дескриптор плотности пикселей (положительное число с плавающей точкой, за которым следует «x». Значение по умолчанию, если отсутствует, равно 1x.)</p><p>В примере мы указываем 1x и 2x картинки, которые будут использоваться браузером на разных экранах, для фолбека описываем img.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_oeeXyx" src="./Модуль 10_files/oeeXyx.html" scrolling="no" frameborder="0" height="311" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-retina-content-img" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Фоновые изображения</h3><p>С фоновыми изображениями этот процесс немного отличается. Используя медиаправила и resolution мы можем указать браузеру при какой пиксельной плотности экрана какое изображение использовать.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_OjjVwz" src="./Модуль 10_files/OjjVwz.html" scrolling="no" frameborder="0" height="305" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-retina-bg-img" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p><strong>Подведем итоги</strong> - для того чтобы изображения были четкими на retina экранах, необходимо экспортировать изображение в n раз больше оригинала. После чего, используя тег picture\img для контентных и медиаправила для фоновых изображений, указать браузеру какое изображение на каком экране мы хотим отобразить.</p></div></section><!-- SECTION --><section id="svg"><h2>Основы работы с SVG</h2><p><strong>SVG (Scalable Vector Graphics)</strong> - векторный формат графики, и язык, основанный на XML, для описания векторных изображений. Внутри файл не бинарный а обычный XML, описывающий объекты, их эффекты и поведение. SVG предназначен для маркировки графики, а не контента. Использовать SVG довольно легко, но есть нюансы, о которых мы должны поговорить.</p><!-- subsection --><h3>Преимущества SVG</h3><ul><li><strong>Масштабирование</strong>: в отличие от растровой графики, SVG не теряет в качестве при масштабировании, поэтому SVG удобно использовать для разработки под retina. При изменении масштаба SVG фигуры всегда перерисовываются, благодаря чему вы всегда будете видеть гладкое и красивое изображение, без пикселизации</li><li><strong>Производительность</strong>: браузеру не нужно запрашивать картинку у сервера, т.к. он сам её рисует, следовательно, производительность повышается</li><li><strong>Удобство</strong>: при помощи CSS/JS можно менять параметры графики на сайте, например фон, прозрачность или границы.</li><li><strong>Анимация и редактирование</strong>: при помощи javascript можно анимировать SVG, а также редактировать в текстовом или графическом редакторе</li><li><strong>Малый размер</strong>: объекты SVG весят намного меньше растровых изображений.</li></ul><p>Когда дело доходит до использования SVG, существует несколько способов. Некоторые из них имеют преимущества, которые могут быть полезны в зависимости от того, чего вы хотели бы достичь, и некоторые из них лучше всего избегать. Если вы хотите просто отобразить картинку без интерактивности вы можете ссылаться на SVG в img или как фоновое изображение в CSS так же, как и на любой другой формат изображения.</p><!-- subsection --><h3>Используем SVG как img</h3><p>Использование SVG как тег <strong>img</strong> ничем не отличается от использования png, jpg или gif, просто указываем url к картинке. Иногда может понадобится атрибут высоты или ширины (или оба). Заметьте, 3 тега img разных размеров и 1 svg, никакой пикселизации даже если вы максимально приблизите браузер так как svg рисуется самим браузером, как текст.</p><p>Для браузеров, которые не поддерживают SVG или в случае фолбека, вы можете ссылаться на PNG или JPG из атрибута src и использовать атрибут srcset для ссылки на SVG. В этом случае только поддерживающие браузеры будут загружать SVG - старые браузеры вместо этого будут загружать PNG. Также можно использовать SVG в элементе picture.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_ayyvWB" src="./Модуль 10_files/ayyvWB.html" scrolling="no" frameborder="0" height="273" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-svg-as-img" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Использование SVG как фон</h3><p>SVG может использоваться как фоновое изображение в CSS, также как PNG, JPG или GIF. Кроме того, мы можем делать все, что можно делать с растровой графикой, например, повторять фон. В приведенном ниже примере старые браузеры будут придерживаться PNG, который они понимают, в то время как более новые браузеры будут загружать SVG</p><div class="cp_embed_wrapper"><iframe id="cp_embed_ayyvqJ" src="./Модуль 10_files/ayyvqJ.html" scrolling="no" frameborder="0" height="310" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-svg-as-bg" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><div class="note"><p><strong>Внимание</strong>: у первых двух методов есть один существенный недостаток, нет возможности изменить цвет SVG изображения или добавить ему анимацию. Они идеально подходят для статической графики.</p></div><!-- subsection --><h3>Используем SVG как Object</h3><p>Object - это в какой-то степени оптимальный вариант для использования, если вы хотите иметь возможность манипулировать SVG, не вкладывая его в свой HTML.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_MvvBwM" src="./Модуль 10_files/MvvBwM.html" scrolling="no" frameborder="0" height="231" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-svg-as-object" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Inline SVG</h3><p>Возможно, лучшим способом использовать SVG является «Inline SVG». То есть, вы можете открыть SVG-файл в текстовом редакторе, скопировать SVG-код и вставить его в HTML-документ. Вставка вашего встроенного SVG-кода будет сохранять HTTP-запрос, но это означает, что изображение не кэшируется браузером. Это самый простой способ манипулировать, однако поддерживать встроенный SVG-код может быть болью.</p><p>Обратите внимание на теги svg, circle и path, последние два это описание фигур внутри svg используя XML. Сейчас нам интересно только то, что мы можем для circle и path дать классы, к которым без проблем можно обратиться из CSS. В дополнительных материалах есть ссылки для более глубокого ознакомления с внутренним устройством SVG.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_ZJJBYj" src="./Модуль 10_files/ZJJBYj.html" scrolling="no" frameborder="0" height="311" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-inline-svg" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p class="accent">Плюсы:</p><ul><li>Inline SVG сохраняет HTTP-запрос и, следовательно, может сократить время загрузки страницы.</li><li>Вы можете назначать классы и идентификаторы элементам SVG и стилизовать их с помощью CSS, либо в SVG.</li><li>Inline SVG - единственный подход, позволяющий использовать интерактивность CSS (например: фокус) и анимации для SVG изображения.</li></ul><p class="accent">Минусы:</p><ul><li>Этот метод подходит только в том случае, если вы используете SVG только в одном месте. Дублирование приводит к излишнему потреблению ресурсов.</li><li>Дополнительный SVG-код увеличивает размер вашего HTML-файла.</li><li>Браузер не может кэшировать встроенный SVG, поскольку он будет кэшировать обычные изображения.</li></ul><!-- subsection --><h3>Продвинутый inline SVG, SVG «спрайт»</h3><p>Сейчас мы научимся использовать SVG так, как это делают в большинстве случаев, если нужна интерактивность. SVG это просто файл, внутри которого, в отличие от растровой графики, описаны фигуры которые браузер отрисует. Внутри одного SVG мы можем задать множество разных групп фигур(symbol), после чего дав каждому символу уникальный id, обратиться к любому из них внутри одного SVG файла. Возможно, звучит несколько запутано, но на самом деле все очень просто.</p><p class="accent">Преимущества</p><ul><li>Один файл, загруженный браузером</li><li>Может быть преобразован с помощью CSS - цвет, переходы, непрозрачность и т.д.</li><li>Более семантический. Это просто ссылка на внешний SVG-файл и хэш</li><li>Нет необходимости в отдельном CSS</li></ul><p>Составление SVG спрайта выходит за рамки данного урока, но в дополнительных материалах вы можете подробно ознакомиться с методами составления таких спрайтов. Сейчас мы кратко разберем что же происходит.</p><p>Итак, в SVG файле мы можем хранить много символов (SVG фигур обернутых в symbol), это по сути и есть SVG «спрайт». К каждому символу мы можем обратиться по id. Результатом этого метода является то, что вы можете использовать следующую разметку в местах, где раньше могли быть элементы span или i. Трюк здесь - это тег <code>use</code> с атрибутом <code>href</code>, указывающий на внешний файл, с хешем, который является идентификатором символа, содержащегося в этом файле.</p><pre class=" language-markup"><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>svg</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>use</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/path/to/svgdef.svg#your-icon<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>use</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>svg</span><span class="token punctuation">&gt;</span></span></code></pre><p class="accent">Давайте разберем пример</p><p>Для наглядности мы вставили весь SVG спрайт в документ (и задав ему id, спрятали), чтобы сэкономить вам время перехода поиска кода SVG (ведь интересно как он там внутри устроен!).</p><p>Итак, обычный SVG, внутри набор XML тегов, svg и symbol, описывающие весь SVG спрайт целиком и каждую фигуру по отдельности. Каждому symbol задан свой id. Ниже мы можем использовать атрибут href и обратиться к символу SVG через хеш (#) и его id. Весь SVG стоит в документе, поэтому нет имени SVG файла перед хешем, если бы данный SVG спрайт лежал удаленно, вне документа, было бы обращение по имени, а потом хеш и id символа. Вот как все просто!</p><div class="cp_embed_wrapper"><iframe id="cp_embed_QMMBpo" src="./Модуль 10_files/QMMBpo.html" scrolling="no" frameborder="0" height="277" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-adv-inline-svg" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- subsection --><h3>Подведем итоги</h3><p>Если вы хотите получить максимальную отдачу от своих SVG, используйте SVG-спрайт. В качестве альтернативы вы можете использовать их inline для сохранения HTTP-запроса, но тогда SVG не будет кэшироваться. Если вы просто хотите использовать SVG, как и любое другое изображение, используйте img или фоновое изображение.</p><div class="note"><p>"внутри svg" означает что некоторые приемы работают, но только если стили находятся непосредственно в svg файле внутри тега style.</p></div><table><tbody><tr><th></th><th>Object</th><th>Inline</th><th>Img</th><th>Background-image</th></tr><tr><td>CSS Manipulation</td><td>да</td><td>да</td><td>внутри svg</td><td>внутри svg</td></tr><tr><td>JS Manipulation</td><td>да</td><td>да</td><td>нет</td><td>нет</td></tr><tr><td>SVG Animation</td><td>да</td><td>да</td><td>да</td><td>да</td></tr><tr><td>Interactive SVG Animation</td><td>да</td><td>да</td><td>нет</td><td>нет</td></tr></tbody></table></section><!-- SECTION --><section id="bem"><h2>Методология BEM</h2><div class="note"><p>There are only two hard problems in Computer Science: cache invalidation and naming things — Phil Karlton</p></div><p>Вопрос о том, как организовать стили на небольших сайтах, обычно не вызывает головной боли. Вы пишете CSS или, возможно, даже какой-то SASS. Вы скомпилируете все это в единую таблицу стилей с производственными настройками SASS, а затем объедините ее, чтобы получить все таблицы стилей из модулей в красивый аккуратный пакет.</p><p>Однако когда дело доходит до более крупных и сложных проектов, как вы организуете свой код, это ключ к эффективности, по крайней мере, в этих трех ситуациях: он влияет на то, как долго вам нужно писать код, сколько из этого кода вам придется писать, и сколько будет загружаться ваш веб сайт. Это становится особенно важным, когда вы работаете с группами пользователей, и когда важна высокая производительность.</p><p>Методология Block, Element, Modifier (обычно называемая BEM) - это популярное соглашение об именах для классов в HTML и CSS. Разработанная командой в Яндексе, ее цель - помочь разработчикам лучше понять взаимосвязь между HTML и CSS в данном проекте. Методология BEM поможет вам создавать повторно используемые компоненты и совместное использование кода в интерфейсной разработке.</p><!-- subsection --><h3>Не BEM'ом единым</h3><p>Существует множество методологий, направленных на снижение нагрузки на CSS, организацию сотрудничества между разработчиками и поддержку больших кодовых баз CSS.</p><ul><li><a href="http://oocss.org/" target="_blank"><strong>OOCSS</strong> </a>- Разделение контейнера и содержимого с помощью CSS-объектов</li><li><a href="http://smacss.com/" target="_blank"><strong>SMACSS</strong> </a>- Стиль-руководство для написания CSS с пятью категориями для правил CSS</li><li><a href="http://suitcss.github.io/" target="_blank"><strong>SUITCSS</strong> </a>- Структурированные имена классов и значимые дефисы</li><li><a href="https://github.com/nemophrost/atomic-css" target="_blank"><strong>Atomic</strong> </a>- Разрушение стилей на атомарные или неделимые части</li></ul><p>Независимо от того, какую методологию вы предпочитаете использовать в своих проектах, вы сможете воспользоваться преимуществами более структурированного CSS и пользовательского интерфейса. Некоторые стили менее строги и более гибки, а другие легче понять и адаптировать в команде.</p><!-- subsection --><h3>Почему именно BEM?</h3><p>Само понятие <code>BEM</code> — не только метод именования селекторов, но парадигма восприятия проекта как набора сущностей (блоки, элементы, модификаторы). Можно выделить следующие преимущества:</p><ul><li>Самодокументируемость.</li><li>Имитация пространства имён (простота и безопасность модификации).</li><li>Отсутствие зависимости от DOM-структуры.</li><li>Проектное реиспользование блоков.</li><li>Кросспроектное реиспользование блоков.</li></ul><p>BEM на сегодняшний день является самой популярной методологией. Он менее запутан, чем другие методы, и предоставляет нам хорошую архитектуру с узнаваемой терминологией.</p><!-- subsection --><h3>Блоки, Элементы и Модификаторы</h3><p>BEM является аббревиатурой ключевых элементов методологии - Block, Element и Modifier. Абсолютно все строится на понимании этих трех ключевых понятий.</p><div class="note"><p>Используя BEM мы полностью (или частично, в контекстных модификаторах) отказываемся от каскадности CSS. Больше нет селекторов вида <code>ul&gt;li&gt;a</code>, обращение к HTML тегам происходит только через классы.</p></div><!-- sub-subsection --><h4>BEM блок</h4><p>Блок — это самостоятельная часть страницы.</p><p>Автономная сущность, которая имеет смысл сама по себе. Абстракция верхнего уровня нового компонента. Блок следует рассматривать как родителя для элементов. Блоки могут быть вложенными и взаимодействовать друг с другом, но семантически они остаются равными. Нет приоритета или иерархии. Блок можно поставить в другую часть страницы, и он будет иметь смысл. К примеру, блоком может быть галерея, статья, виджет сайдбара, сам сайдбар, навигация, форма и т.д. Т.е. блок - это независимый компонент интерфейса.</p><ul><li>Название класса должно быть простым и коротким, имена блоков могут состоять из латинских букв, цифр и тире.</li><li>Название класса должно отвечать на вопрос «Что это?»</li><li>Название не должно отвечать на вопрос «Как выглядит?»</li></ul><div class="cp_embed_wrapper"><iframe id="cp_embed_GvvVva" src="./Модуль 10_files/GvvVva.html" scrolling="no" frameborder="0" height="319" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-bem-block" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p>Блоки можно и нужно вкладывать друг в друга.</p><ul><li>Нет ограничений на вложения блоков, помимо здравого смысла.</li><li>Никакой дополнительной специфики вложенные блоки не имеют.</li></ul><!-- sub-subsection --><h4>BEM элемент</h4><p><strong>BEM элемент</strong> - это неотъемлемая часть блока, которая не имеет отдельного значения и семантически привязана к ее блоку. К примеру, элемент меню, заголовок или текст в статье, картинка галереи и т.д.</p><ul><li>Название класса формируется из названия блока с добавлением __ и названия элемента.</li><li>Название класса должно быть простым и коротким.</li><li>Название класса должно отвечать на вопрос «Что это?»</li><li>Название не должно отвечать на вопрос «Как выглядит?»</li></ul><p>Давайте добавим заголовок, картинку и текст к нашей статье. Вне статьи этот контент не имеет никакого смысла, он жестко привязан к статье, значит это элементы.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_qXXexy" src="./Модуль 10_files/qXXexy.html" scrolling="no" frameborder="0" height="497" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-bem-element" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p>Почему нельзя просто так располагать элемент вне блока:</p><ul><li>теряется логика разметки</li><li>сложно стилизовать элементы, которые могут оказаться где угодно (float, абс. позиционирование и некоторые другие стили такого элемента могут «сломать» верстку)</li></ul><div class="note"><p>Элементов может не быть. Не у всех блоков должны быть элементы: кнопка — всегда BEM-блок, но BEM-элементы у неё внутри встречаются относительно редко. Разве что иконка.</p></div><!-- sub-subsection --><h4>Как отличить BEM-блок и BEM-элемент</h4><p>Просто задайте себе вопрос: «Эта сущность может потребоваться мне отдельно, сама по себе? Или она нужна только внутри её родителя?» Если нужна отдельно — это BEM-блок, если мыслима только внутри родителя — это BEM-элемент.</p><p>В действительно сомнительных случаях делайте выбор в пользу BEM-блока.</p><p>На всех проектах (кроме совсем уж крошечных или имеющих гарантировано нулевую возможность модификации) есть фрагменты дизайна, которые мудро всегда делать BEM-блоками по причине высокой вероятности повторения.</p><p>Некоторые фрагменты интерфейса — всегда BEM-блоки:</p><ul><li>Кнопка (любые кнопки)</li><li>Блоки внутри форм (блок для текстового поля, блок для радиокнопки и т.п.)</li><li>Пагинация</li><li>Табы</li><li>Лейблы (метки)</li><li>Социальные ссылки</li><li>«Лайк» со счётчиком</li></ul><!-- sub-subsection --><h4>BEM модификатор</h4><p>Модификатор — дополнительный класс для смены оформления или поведения. Флаг на блоке или элементе. Используется для изменения внешнего вида, поведения или состояния. К примеру, выбранная кнопка, эффект ховера, выбранный кастомный чекбокс, изменение размеров или цвета.</p><ul><li>Название класса формируется из названия блока/элемента с добавлением -- и названия модификатора.</li><li>Название должно быть простым и коротким.</li><li>Название класса может отвечать на вопросы «Что это?», «Что меняется?», «Чем отличается от прочих?»</li></ul><div class="note"><p>Класс модификатор никогда не должен использоваться самостоятельно, но всегда только с тем классом, который он модифицирует.</p></div><p>Добавим к нашей статье еще кнопку, после чего создадим еще 2 такие же статьи, но в каждой цвет кнопки будет отличаться. Мало того, мы еще добавим модификатор для еффекта ховера.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_BddXbj" src="./Модуль 10_files/BddXbj.html" scrolling="no" frameborder="0" height="555" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-bem-modifier" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h4>Миксование</h4><p>Миксование — комбинирование на одном теге классов BEM-блока и BEM-элемента. Комбинация возможна в любом сочетании: BEM-блок + BEM-элемент, BEM-блок + BEM-блок, BEM-элемент + BEM-элемент. Этот подход позволяет:</p><ul><li>Добавить некоторые стилевые свойства, необходимые только в месте добавления (использование модификатора нерационально). Например для <code>.btn</code> внутри .page-header необходим внешний левый отступ в <code>30px</code>. Можно дописать для тега с .btn дополнительный класс <code>.page-header__btn</code> и дать отступ с помощью этого селектора. Это нормальная практика, её можно использовать.</li><li>Объединить стилизацию 2-х и более блоков. Например для <code>.article</code> и для <code>.page-footer__section</code> шрифтовые свойства одинаковы. Можно вынести определение шрифтовых свойств в новый блок <code>.text</code> и дописать этот класс на <code>.article</code> и <code>.page-footer__section</code>. Этот подход излишне связывет части страницы (напоминает OOCSS и класс-хелпер), не делайте так.</li><li>Обойтись без тега-обёртки с добавляемым селектором. Например страница каталога, 7+ товаров в потоке, каждый товар — <code>.product</code>, но каждому элементу потока нужны стилевые свойства ячеек модульной сетки (по которой выстроен потоковый вывод). Можно добавить для <code>.product</code> класс ячейки модульной сетки, что бы не делать обертку с этим классом. Это чревато конфликтом отступов/размеров, не смешивайте на одном теге классы обёртки и содержимого.</li></ul><!-- sub-subsection --><h3>Вложенность блоков и элементов</h3><p><strong>Блок</strong> - это просто раздел документа, такой как <code>header</code>, <code>footer</code>, <code>sidebar</code> и т.д. Блоки могут содержать другие блоки. Например, блок заголовка может также содержать блоки логотипа, навигации и формы поиска и т.д., которые в свою очередь могут содержать элементы или другие блоки.</p><p>Важно понимать разделение иерархии HTML документа и иерархии BEM классов. При HTML разметке, BEM блок может быть вложен в элемент, как тег в теге, но при этом он не является элементом блока или элементом элемента.</p><div class="note"><p>Простое правило: максимальная запись BEM класса может выглядеть только так: <code>.block__element--modifier</code>. Если у вас есть множественные имена блоков, элементов или модификаторов при записи класса, вы допустили ошибку.</p></div><p>Используя наши статьи из предыдущих примеров, создадим секцию статей. Секция это блок, у него есть элементы заголовка, тела и итемов (в которых будет располагаться произвольный контент). В итемы секции помещаем наши статьи, все хорошо работает. Обратите внимание, что у статей нет ширины, ширину мы задали элементам секции. По методологии BEM, блок не может иметь внешних отступов (и иногда ширины), чтобы не нарушать внешнюю геометрию (оттолкнуть другие блоки при изменении своего расположения на странице).</p><div class="cp_embed_wrapper"><iframe id="cp_embed_jLGEYr" src="./Модуль 10_files/jLGEYr.html" scrolling="no" frameborder="0" height="709" allowtransparency="true" allowfullscreen="true" name="CodePen Embed" title="core-module-10-bem-hierarchy" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><!-- sub-subsection --><h3>Заключение</h3><p>Повторим и подведем итоги. Методология BEM побуждает дизайнеров и разработчиков думать о веб-сайте как о наборе многоразовых блоков компонентов, которые можно смешивать и сопоставлять для создания интерфейсов.</p><p class="accent">Плюсы BEM</p><ul><li><strong>Модульность</strong> - стили блоков никогда не зависят от других элементов на странице, поэтому вы никогда не столкнетесь с каскадом. Вы также получаете возможность использовать одни блоки в разных проектах.</li><li><strong>Повторное использование</strong> - составляя независимые блоки по-разному и используя их разумно, уменьшает количество кода CSS, который вам нужно будет поддерживать. Благодаря набору руководств по стилю вы можете создать библиотеку блоков, что сделает ваш CSS супер эффективным.</li><li><strong>Структура CSS</strong> - методология BEM дает вашему CSS-коду прочную структуру, которая остается простой и понятной.</li></ul><div class="note"><p>Чтобы научиться использовать BEM правильно, требуется время и практика, много практики. Нужно более глубоко смотреть на структуру страницы, прорабатывать варианты и связи между блоками и элементами. В дополнительных материалах есть ссылки на статьи, в которых приводятся дополнительные примеры.</p></div></section><!-- SECTION --><section id="resources"><h2>Дополнительные материалы</h2><ul><li><a href="https://www.w3.org/wiki/Graceful_degradation_versus_progressive_enhancement" target="_blank">Статья W3C о GD и PE</a></li><li><a href="https://css-tricks.com/snippets/css/retina-display-media-query/" target="_blank">Список медиаправил для Retina экранов</a></li><li><a href="https://svgontheweb.com/" target="_blank">Большой ресурс, посвященный SVG</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial" target="_blank">Полное руководство по SVG на MDN</a></li><li><a href="https://github.com/yoksel/common-words" target="_blank">Справочник имен классов</a></li><li><a href="https://css-tricks.com/bem-101/" target="_blank">BEM на CSS-tricks</a></li><li><a href="https://www.sitepoint.com/css-architecture-block-element-modifier-bem/" target="_blank">Статья о BEM философии на sitepoint</a></li></ul></section></article><!-- ===== #page-navigator ======  --> <a href="http://fecore.net.ua/theory/module-10.html#main-nav" class="to-page-nav"></a><!-- ===== #end page-navigator =====  --></div></body></html>
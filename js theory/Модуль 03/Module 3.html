<!DOCTYPE html>
<!-- saved from url=(0059)http://fecore.net.ua/javascript/pages/theory/module-03.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Module 3</title><link rel="stylesheet" href="./Module 3_files/styles.min.css"><script async="" src="./Module 3_files/scripts.min.js.Без названия"></script></head><body class="theory-page"><div class="wrapper"><article><header><h1>Модуль 3 - Теория</h1><nav class="table-of-contents" id="main-nav"><ol class="page-nav"><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#entry">Введение в функции</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#fn-basics">Определение функции</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#call-stack">Стек вызовов</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#scope">Область видимости</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#args">Псевдомассив arguments</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#arr-fn">Стрелочные функции</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#iife">IIFE</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#guard-clause">Паттерн Guard Clause</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#cb-fn">Функции обратного вызова</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#closure">Замыкания</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#recursion">Рекурсия</a></li></ol></nav></header><section><h2 id="entry">Введение в функции</h2><p>Очень часто при создании программ участок кода повторяется. А если программа очень большая, то возникает необходимость использовать повторно подобные участки кода, зачастую с новыми начальными значенниями. Воплощением этой идеи явлюятся функции.</p><p>Вы уже видели вызовы функций, таких как <code>alert</code>, <code>console.log</code>, <code>Array.push</code>, <code>String.includes</code> и многие другие. Идея оборачивания куска программы и вызова её как переменной очень востребована. Это инструмент для структурирования больших программ, уменьшения повторений, назначения имён подпрограммам, и изолирование подпрограмм друг от друга.</p><p>Функция является независимой частью кода, связывающей один или несколько входных параметров с одним или несколькими выходными параметрами. Функции (также известные как процедуры и подпрограммы) можно представить как черный ящик, они получают что-то на входе (данные), и отдают что-то на выходе (результат выполнения кода внутри функции).</p><img src="./Module 3_files/fn-basics.png" alt="function as a box"></section><section><h2 id="fn-basics">Определение функции</h2><p>Определение функции – обычное определение переменной, где значение, которое получает переменная, является функцией.</p><p>Имя функции - глагол с маленькой буквы, отвечающий на вопрос <strong>"что сделать?"</strong>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Выше записана переменная <code>add</code>, значением которой будет функция. Такая запись называется <code>функциональным выражением (function expression)</code>. Функция будет получать 3 значения и возвращать результат сложения этих значений.</p><p>Разберем синтаксис:</p><ul><li>Функция создаётся <code>выражением</code>, начинающимся с ключевого слова <code>function</code>, за которым может следовать имя функции, об этом позже.</li><li>Затем в круглых скобках идут <code>параметры</code>: перечисление данных которые функция будет получать из вне, необходимых функции для вычисления, записываются в виде имен переменных в круглых скобках. В данном случае <code>a</code>, <code>b</code> и <code>с</code>. У функции может быть несколько параметров, или вообще их не быть, тогда записываются просто пустые круглые скобки <code>()</code>.</li><li>Далее идет <code>тело функции</code>, заключенное в фигурные скобки <code>{}</code>, содержащее инструкции которые необходимо выполнить при вызове функции. Тело функции всегда заключают в фигурные скобки, даже если оно состоит из одной инструкции.</li><li>Инструкция <code>return</code> определяет значение, возвращаемое функцией. Когда обработка программы доходит до этой инструкции, она сразу же выходит из функции, и возвращает это значение в то место кода, откуда была вызвана функция.</li><li><code>return</code> без выражения возвращает значение <code>undefined</code>. При отсутствии в теле функции слова <code>return</code> функция все равно вернет значение <code>undefined</code>.</li></ul><div class="note"><p>Процесс написания функций может быть сложен, поэтому деление этого процесса на несколько частей вместо попытки реализовать всё за один большой шаг — хорошая идея.</p></div><p>Затем, при необходимости, функция <code>вызывается</code> с помощью имени и круглых скобок, внутри которых могут быть записаны <code>аргументы</code>.Важно различать два термина: <code>параметры</code> и <code>аргументы</code> функции.</p><ul><li>Термин <code>аргументы</code> используется при вызове функции, когда мы передаем значения в вызов функции.</li><li>Термин <code>параметры</code> используется при объявлении функции, это те локальные переменные внутри функции, в которые будут записаны <code>значения аргументов</code> во время вызова функции.</li></ul><p>Параметры – обычные переменные, но их начальные значения задаются при вызове функции, а не в коде её тела, и доступны они только внутри функции.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token comment">// a,b,c это параметры</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//  1, 2, 3 это аргументы</span>
<span class="token keyword keyword-let">let</span> result <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> result <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span></code></pre><div class="note"><p>Как и для обычной переменной, в такой записи происходит подъем (hoisting) переменной. Вызов функции до ее объявления приведет к ошибке.</p></div><p>Все программы либо вычисляют какое-то значение и возвращает его в виде результата, либо изменяют свое состояние таким образом, что это влияет на дальнейшее выполнение кода.</p><p>Функция может либо вызвать побочные эффекты, либо возвращают результат своей работы, зависит от задачи.</p><p>В компьютерной литературе побочным эффектом называют изменение состояние программы. В зависимости от того, какой фрагмент кода будет помещен внутри функции, произойдет либо возврат вычисленного значения либо изменение состояния программы.</p><h3>Именованное функциональное выражение</h3><p>Функциональное выражение может иметь также второе имя - после слова <code>function</code>, в таком случае это <code>именованное функциональное выражение (Named Function Expression)</code>.</p><p>Если у такой функции изменить имя после слова <code>function</code> и сделать это имя отличным от имени слева от оператора присваивания, то таким измененнным именем можно пользоваться только внутри самой функции для вызова самой себя (к примеру для рекурсии). О рекурсии мы поговорим поздже, сейчас нам важна сама концепция.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token comment">// Счетчик от n до нуля с записью в console.log</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">countDownFrom</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">fn</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">countDownFrom</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5, 4, 3, 2, 1, 0</span></code></pre><h3>Объявление функции</h3><p>Есть более короткая версия создания функции. Ключевое слово <code>function</code> можно использовать в начале инструкции. Это <code>объявление функции (function declaration)</code>. Инструкция определяет переменную <code>add</code> и присваивает ей заданную функцию. Эта форма записи не требует обязательной точки с запятой после закрытия фигурной скобки тела функции.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">add</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><img src="./Module 3_files/fn-dec.png" alt="function declaration" width="400"><p>Особенностью этого синтаксиса является то, что функцию можно вызвать до ее объявления в коде.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"text"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// text</span>

<span class="token keyword keyword-function">function</span> <span class="token function">add</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-function">function</span> <span class="token function">print</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Такой код работает, хотя функция объявляется ниже того кода, который её использует. Это происходит оттого, что объявления функций не являются частью обычного исполнения программ сверху вниз. Они «перемещаются» наверх области видимости в которой были объявлены и могут быть вызваны в любом месте внутри этой области.</p><p>Иногда это удобно, потому что вы можете писать код в таком порядке, который выглядит наиболее осмысленно, не беспокоясь по поводу необходимости определять все функции выше того места, где они используются.</p><h3>Параметры по умолчанию</h3><p>При вызове функции не обязательно указывать все значения аргументов, которые перечислены в параметрах функции. Но иногда параметрам, которым не передали значение через аргумент, бывает необходимо передать какое-то значение, отличное от <code>undefined</code>.</p><p>До ES6 присвоение по умолчанию делали следующим образом.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">showTestDays</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>str<span class="token punctuation">,</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> testDays <span class="token operator">=</span> <span class="token keyword keyword-typeof">typeof</span> num <span class="token operator">!==</span> <span class="token string">"undefined"</span> <span class="token operator">?</span> num <span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-const">const</span> name <span class="token operator">=</span> <span class="token keyword keyword-typeof">typeof</span> str <span class="token operator">!==</span> <span class="token string">"undefined"</span> <span class="token operator">?</span> str <span class="token punctuation">:</span> <span class="token string">"неизвестно"</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-return">return</span> <span class="token template-string"><span class="token string">`Имя - </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, использовано </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>testDays<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> тестовых дня(ей)`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">showTestDays</span><span class="token punctuation">(</span><span class="token string">"Екатерина"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// "Имя - Екатерина, использовано 10 тестовых дня(ей)"</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">showTestDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// "Имя - неизвестно, использовано 30 тестовых дня(ей)"</span></code></pre><p>При такой записи если тип значения параметра не равен <code>"undefined"</code>, то в переменную записывается значение параметра, в противном случае записывается значение по умолчанию. Это не очевидно для неопытного разработчика. Кроме того получается слишком много лишнего кода. Конечно эту проверку можно вынести в функцию, но и в таком случае код будет не очень хорошим.</p><p>ES6 позволяет сделать то же самое, но более очевидным и простым образом.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">showTestDays</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"неизвестно"</span><span class="token punctuation">,</span> days <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> <span class="token template-string"><span class="token string">`Имя - </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, использовано </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>days<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> тестовых дня(ей)`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">showTestDays</span><span class="token punctuation">(</span><span class="token string">"Екатерина"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// "Имя - Екатерина, использовано 10 тестовых дня(ей)"</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">showTestDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// "Имя - неизвестно, использовано 30 тестовых дня(ей)"</span></code></pre></section><section><h2 id="call-stack">Стек вызовов</h2><p><strong>Стек</strong> — структура данных, которая работает по принципу: «последним пришёл — первым вышел». Последнее, что вы добавили в стек, будет удалено первым из него. Это происходит из-за того, что мы можем только добавить или удалить элементы из верхушки стека.</p><p>Вы уже знаете массивы. Представьте стек как массив у которого есть только методы <code>pop</code> и <code>push</code>, то есть мы можем только добавить или удалить элемент в конце коллекции.</p><p>Полезным будет присмотреться к тому, как порядок выполнения кода работает с функциями. Вот простая программа с несколькими вызовами функций.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Привет </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">"Mango"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"До свидания!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Обрабатывается она примерно так</p><ul><li>вызов <code>greet</code> заставляет проход прыгнуть на начало функции.</li><li>он вызывает встроенную функцию <code>console.log</code>, которая перехватывает контроль, делает своё дело и возвращает контроль.</li><li>потом он доходит до конца <code>greet</code>, и возвращается к месту, откуда <code>greet</code> вызвали.</li><li>следующая строчка опять вызывает <code>console.log</code>.</li></ul><p>Схематично это можно показать так:</p><pre class=" language-javascript"><code class=" language-javascript">top
  <span class="token operator">=&gt;</span> greet
     <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span>log
  <span class="token operator">=&gt;</span> greet
top
  <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span>log
top</code></pre><p>Поскольку функция должна вернуться на то место, откуда её вызвали, компьютер должен запомнить контекст, из которого была вызвана функция. В одном случае, <code>console.log</code> должна вернуться обратно в <code>greet</code>. В другом, она возвращается в конец программы.</p><p>Место, где компьютер запоминает контекст, называется стеком. Каждый раз при вызове функции, текущий контекст помещается наверх стека. Когда функция возвращается, она забирает верхний контекст из стека и использует его для продолжения работы.</p><p>Хранение стека требует места в памяти. Когда стек слишком сильно разрастается, компьютер прекращает выполнение.</p><p><strong>Обязательно</strong> посмотрите видео по ссылкам ниже. Нет необходимости сейчас разбираться с темой видео на 100%, достаточно будет общего, базового понимания внутренних процессов. На протяжении курса возвращайтесь к этому видео и освежайте его в памяти.</p><ul><li><a href="https://youtu.be/8cV4ZvHXQL4" target="_blank" rel="noopener">Про цикл событий в JavaScript? (перевод)</a></li><li><a href="https://youtu.be/8aGhZQkoFbQ" target="_blank" rel="noopener">What the heck is the event loop anyway? (оригинал)</a></li><li><a href="https://youtu.be/j4_9BZezSUA" target="_blank" rel="noopener">Jake Archibald: все что я знаю про Event Loop в JavaScript (перевод)</a></li><li><a href="https://youtu.be/cCOL7MC4Pl0" target="_blank" rel="noopener">Jake Archibald: In The Loop (оригинал)</a></li></ul></section><section><h2 id="scope">Область видимости</h2><p><strong>Область видимости функции (Scope)</strong> - это доступность переменных в определенной части кода во время выполнения, набор переменных к которым функция имеет доступ. Определяется местом создания функции, а не местом вызова.</p><p>В JavaScript есть два типа области видимости: глобальная и локальная. Переменные, определенные внутри функции, инструкций <code>if</code>, циклов и других блоков кода находятся в ее локальной области видимости, в то время как переменные, определенные вне функции, находятся в глобальной области видимости.</p><p>Это принцип наименьшего доступа. Наши функции должны иметь доступ только к тем переменным, которые им необходимы.</p><p>Scope также решает проблему именования, когда у вас есть переменные с тем же именем, но в разных областях видимости.</p><pre class=" language-javascript"><code class=" language-javascript">сonst value <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> num <span class="token operator">+</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-let">let</span> isHappy <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span></code></pre><p>Переменная <code>value</code> , функция <code>add</code> и переменная <code>isHappy</code> — все во внешнем окружении, находятся в глобальной области видимости. Область видимости означает - "область, где переменные доступны".</p><p>Внутри функции <code>add</code> есть переменная <code>x</code>. Поскольку она внутри блока кода, это локальная переменная, а не глобальная. Она видна только внутри этой функции, но не снаружи. У неё локальная область видимости.</p><p>В функции <code>add</code> есть ещё одна переменная из локальной области видимости — аргумент <code>num</code>. Он не задан так же чётко, как переменные, но ведёт себя почти как локальная переменная.</p><p>Важное свойство функций в том, что функции создают собственную область видимости (фигурные скобки тела функции ограничивают эту область). Переменные, созданные внутри функции (включая параметры), локальны внутри этой функции.</p><div class="note"><p>Любой блок кода окружёный фигурными скобками <code>{}</code>, создает новую локальную область видимости и соответственно лексическое окружение.</p></div><p>Это означает, что переменная созданная с помощью <code>var</code>, <code>let</code> или <code>const</code> внутри функции не будет доступна коду вне этой функции. А также то, что эти переменные будут создаваться каждый раз при вызове функции, и их отдельные инкарнации никак друг с другом не связаны.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> num <span class="token operator">+</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// У нас нет доступа к x снаружи add, x тут не существует</span>
<span class="token comment">// console.log вызывается в глобальном окружении,</span>
<span class="token comment">// а x не задан в этом глобальном окружении.</span>
<span class="token comment">// Поэтому мы получаем Reference Error.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ReferenceError: x is not defined</span></code></pre><p>Создадим глобальный <code>x</code> вне тела функции. Его значение будет выведено на экран, но локальный <code>x</code> внутри функции <code>add</code> по прежнему виден только внутри этой функции. Эти два <code>x</code> не имеют ничего общего друг с другом, они находятся в разных окружениях. Они не схлопываются в одно целое, не смотря на то, что у них одно и то же имя.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> x <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> num <span class="token operator">+</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// x объявлен глобально и поэтому доступен.</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 50</span></code></pre><p>Эта локальность переменных применяется только к параметрам и созданным внутри функций переменным. Переменные, заданные снаружи какой бы то ни было функции, называются глобальными, поскольку они видны на протяжении всей программы. Получить доступ к таким переменным можно и внутри функции, если только вы не объявили локальную переменную с тем же именем (как в примере выше).</p><div class="note"><p>Подъём переменных внутри области видимости функции происходи также, как и в глобальной области видимости - переменные поднимаются в начало области видимости этой функции.</p></div><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> outerString <span class="token operator">=</span> <span class="token string">"Меня видно внутри и снаружи."</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> innerString <span class="token operator">=</span> <span class="token string">"Меня видно только внутри fn."</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"In: outerString says - "</span> <span class="token operator">+</span> outerString<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// "In: outerString says - Меня видно внутри и снаружи."</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"In: innerString says - "</span> <span class="token operator">+</span> innerString<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// "In: innerString says - Меня видно только внутри fn."</span>
<span class="token punctuation">}</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Out: outerString says - "</span> <span class="token operator">+</span> outerString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// "Out: outerString says - Меня видно внутри и снаружи. "</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Out: innerString says - "</span> <span class="token operator">+</span> innerString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Ошибка, переменная innerString необъявлена в этой области</span>
<span class="token comment">// видимости, она доступна только внутри фукции fn</span></code></pre><p>Такое поведение помогает предотвратить случайное взаимодействие между функциями. Если бы все переменные использовались в любом месте программы, было бы очень трудно убедиться, что одна переменная не используется по разным назначениям.</p><p>А если бы вы использовали переменную повторно, то столкнулись бы со странными эффектами, когда сторонний код портит значения вашей переменной. Относясь к локальным для функций переменным так, что они существуют только внутри функции, язык делает возможным работу с функциями будто с отдельными маленькими вселенными, что позволяет не волноваться про весь код целиком.</p><div class="warn"><p>Хоть это и заманчиво всё помещать в глобальную область видимости и забыть о сложностях раздельных окружений — это ужасная практика. Глобальные переменные делают ваш код невероятно хрупким. В таком случае что угодно может сломать что угодно. Поэтому избегайте глобальной области видимости, храните вещи там, где им место.</p></div><h3>Лексическое окружение (LexicalEnvironment)</h3><p><strong>Лексическое окружение </strong>—  это термин, описывающий связывание идентификаторов с переменными и функциями, основанное на лексической вложенности кода, написанного на Javascript. Лексическое окружение состоит из таблицы символов и ссылки на внешнее лексическое окружение (нулевой для глобального окружения). Обычно лексическое окружение связано с синтаксической конструкцией в коде, такой как объявление функции.</p><p>По простому <strong>лексическое окружение</strong> — это структура для хранения связей имен переменных и их значений в памяти и механизм для извлечения этих значений при обращении по имени.</p><p>Каждый раз, когда в программе вызывается функция, внутри интерпретатора создается специальный словарь <strong>LexicalEnvironment (лексическое окружение)</strong>, привязанный к этому вызову. Все определения внутри функции автоматически записываются в словарь. Имя определения становится ключом, а значение определения становится значением в словаре. К таким определениям относятся аргументы, константы, функции, переменные и тд.</p><p><strong>Словарь</strong> — это набор пар «ключ - значение». Зная ключ можно получить значение. Точно так же, как и при работе с обычным бумажным словарем, где ключ — это слово, а значение — определение слова. На данный момент нам важно только концептуальное понимание, без конкретных реализаций в языке.</p><p>В примере ниже в комментариях показано состояние словаря перед выполнением каждой строчки кода. Не забывайте, что наполнение словаря происходит при вызове функции, а не при определении.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">greet</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// LexicalEnvironment = { name: 'Mango' }</span>
  <span class="token keyword keyword-const">const</span> message <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Good day to you </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>

  <span class="token comment">// LexicalEnvironment = {</span>
  <span class="token comment">//    message: 'Good day to you Mango',</span>
  <span class="token comment">//    name: 'Mango'</span>
  <span class="token comment">//  }</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">greet</span><span class="token punctuation">(</span><span class="token string">'Mango'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Good day to you Mango</span></code></pre><p>В процессе выполнения функции, значения переменных могут меняться, что сразу же отражается в лексическом окружении. В конце выполнения функции её лексическое окружение уничтожается, а занятая им память высвобождается.</p><p>Но окружение есть не только у функций. Существует и глобальное окружение. Например, мы с легкостью используем такие функции, как <code>console.log</code> или <code>alert</code> даже не сильно задумываясь откуда они берутся.</p><p>Дело в том, что интерпретатор производит поиск значения идентификатора не только в локальном лексическом окружении (в том, где используется идентификатор), но и во внешнем окружении. Поиск начинается с локального окружения, и если в нём не найден нужный идентификатор, то просмотр идет дальше вплоть до уровня модуля, а затем и до глобального уровня.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> number <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> number <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 15</span></code></pre><p><strong>Окружение — это не</strong> «всё, что было объявлено до функции, в которой я использую эти объявления». Не важно, что <code>number</code> появился позже использования внутри функции. Главное, что вызов функции <code>add</code> происходит позже определения <code>number</code>, а значит к этому времени идентификатор уже был добавлен в окружение, внутри которого была создана функция <code>add</code>.</p><h3>Лексическая область видимости</h3><p>Давайте разберем пример. Функция <code>add</code> возвращает сумму <code>a</code> и <code>b</code>. <code>a</code> задано внутри функции, <code>b</code> — нет.</p><p>Пытаясь решить выражение <code>a + b</code>, JavaScript ищет значения <code>a</code> и <code>b</code>. Он начинает искать локально и выходит наружу, по одной области видимости за шаг, пока он не найдёт то, что ему нужно или пока не поймёт, что это невозможно найти.</p><p>Поэтому в данном примере JavaScript начинает с поиска a внутри локальной области видимости — внутри функции <code>add</code>. Он находит значение сразу и переходит к <code>b</code>. Невозможно найти значение <code>b</code> в локальной области видимости, поэтому он переходит к наружной области. Тут он находит <code>b</code> — это 10. <code>a + b</code> превращается в <code>5 + 10</code>, в результате получаем <code>15</code>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword keyword-const">const</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 15</span></code></pre><p>JavaScript пытается сначала найти переменную в той области видимости, в которой к ней обратиились (текущей). Если такой переменной в локальной области видимости нет, то JavaScript выходит наружу, на один уровень за попытку, пока не найдёт значение или не дойдет до самой верхней области видимости (глобальной) и поймет, что переменную с таким именем невозможно найти, так как ее просто нигде нет, тогда будет ошибка о том, что переменная не объявлена.</p><p>Здесь, в выражении <code>a + b</code> , функция <code>add</code> использует локальную <code>a</code> (потому что она обнаружена локально), и внешнюю <code>b</code> (потому что локально <code>b</code> найдена не была).</p><div class="note"><p>Внешним окружением по отношению к функции считается окружение, в котором функция была объявлена, а не вызвана!</p></div><p>Весь этот кусок кода мог бы быть внутри другой функции, и ещё внутри другой функции. И если бы <code>b</code> не нашлась здесь, JavaScript продолжил бы искать <code>b</code> за пределами функции, слой за слоем. Заметьте, что <code>a = 20</code> не затронула вычисления, <code>a</code> была найдена внутри, поэтому внешняя <code>a</code> не сыграла роли. Это называется лексической областью видимости. Область видимости любой переменной определяется местом расположения этой переменной внутри кода, и вложенные блоки имеют доступ к их внешним областям видимости.</p><h3>Вложенные области видимости</h3><p>JavaScript различает не только глобальные и локальные переменные. Функции можно задавать внутри функций, что приводит к нескольким уровням локальности.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-let">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword keyword-function">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-let">let</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">// свободная переменная</span>

  <span class="token keyword keyword-function">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-let">let</span> z <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span> <span class="token comment">// свободная переменная</span>
    <span class="token keyword keyword-return">return</span> x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword keyword-return">return</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Функция <code>bar</code> видит переменную <code>x</code> и <code>y</code>, потому что она находятся внутри функции, в которой она определена ( <code>foo</code>). А все снаружи функции <code>foo</code> не видит ни одной из переменных, определённых внутри этой функции.</p><p>Проще говоря, в каждой локальной области видимости можно увидеть все области, которые её содержат. Набор переменных, доступных внутри функции, определяется местом, где эта функция описана в программе.</p><p>Все переменные из блоков, окружающих определение функции, видны – включая и те, что определены на верхнем уровне в основной программе. Этот подход к областям видимости называется лексическим.</p><h3>Перекрытие (shadowing)</h3><p>Перекрытием называется ситуация, когда во внутреннем окружении создается идентификатор с таким же именем как и во внешнем. Причем не важно что это, аргумент функции, константа или переменная.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-let">let</span> value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-let">let</span> value <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span></code></pre><p>Несмотря на то что, сам код остается рабочим, перекрытие больше не позволяет обратиться к идентификатору из внешнего окружения, ведь поиск всегда происходит сначала в локальном окружении, а уже затем во внешних.</p><p>Но еще большей проблемой является то, что такой код сложнее в анализе. Глядя на него недостаточно видеть имена, нужно также учитывать их контекст, так как одно и тоже имя на разных строках может означать разные вещи. Перекрытие усложняет код и поэтому считается плохой практикой программирования.</p><p><a href="https://habrahabr.ru/post/149526/" target="_blank">Стаья о лексическом окружении в JavaScript</a></p></section><section><h2 id="args">Псевдомассив arguments</h2><p>В JavaScript важен порядок объявления параметров фукнции. Не существует никакого другого механизма пояснить компилятору как значения аргументов функции при вызове связаны с параметрами.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">pow</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>base<span class="token punctuation">,</span> exponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> exponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`2 ** 10 =  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "2 ** 10 =  1024"</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`10 ** 2 =  </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "10 ** 2 =  100"</span></code></pre><p>Такой порядок обеспечивается тем, что каждая функция имеет локальную переменную <code>arguments</code>, доступную внутри любой функции. Порядок объявления параметров соответствует порядку объявления аргументов при вызове функции - значение первого аргумента будет присвоено первому параметру, второго аргумента - второму параметру и т.д. А переменная <code>arguments</code> хранит значения аргументов в порядке объявления.</p><p>Эта переменная является <code>псевдомассивом</code> - множеством, имеющим свойство <code>length</code> и возможностью обратится к элементу множества как в массиве, но полным отсутствием методов для работы с массивом. Такой способ хранения данных еще называют индексированный список или ассоциативный массив пар "ключ-значение", где в качестве ключа выступают индексы-числа.</p><p>Псевдомассив содержит список <code>аргументов</code>, переданных функции при вызове, но количество аргументов может не совпадать с количеством параметров - это не приведет к ошибке.</p><p>Если параметров будет меньше, чем аргументов, то компилятор присвоит значение <code>undefined</code> параметрам без аргументов. Если больше, то доступ к таким аргументам можно будет получить через <code>arguments</code>.</p><p>Единственная сложность в том, что псевдомассив не имеет методов массива. Поэтому для <code>arguments</code> используют либо циклы, либо приводят к массиву.</p><p>Рассмотрим пример использования <strong>arguments</strong> в функции, которая суммирует любое количество аргументов:</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">summ</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> max <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token keyword keyword-let">let</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-let">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> max<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res <span class="token operator">+=</span> arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword keyword-return">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`sum = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "sum = 15"</span></code></pre><h3>Способы преобразовать псевдомассив</h3><p>На практике используют три основных способа преобразования псевдомассива в массив.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token comment">// Используя метод Array.from,</span>
<span class="token comment">// который создаст массив из итерируемого объекта</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn1</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> args <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword keyword-from">from</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// полноценный массив</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Создав новый массив используя оператор spread ...</span>
<span class="token comment">// Это аналог оператора rest, только spread распыляет коллекцию</span>
<span class="token comment">// в то время как rest наоборот собирает значения в коллекцию</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn2</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// полноценный массив</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Собрав все аргументы используя оператор rest</span>
<span class="token comment">// прямо в подписи функции</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn3</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// args это полноценный массив</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></section><section><h2 id="arr-fn">Стрелочные функции</h2><p>В ES6 появился новый синтаксис функций. Стрелочные функции имеют сокращенный, более лаконичный синтаксис. Подобно функциональным выражениям они присваиваются переменным или могут быть анонимными. Их использование выглядит очень удобным и значительно сокращает объемы необходимого кода.</p><h3>Синтаксис стрелочных функций</h3><p>Все стрелочные функции создаются с помощью <code>function expression</code>, если функция не анонимна, то она должна быть присвоена переменной. Поэтому следует помнить, что перед использованием стрелочной функции её всегда необходимо создать заранее.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token comment">// Обычное функциональное выражение</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Тоже самое записно как стрелочная функция</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span></code></pre><p>Слово <code>function</code> не используется, вместо этого сразу идет объявление параметров. За параметрами всегда следует символ <code>=&gt;</code>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token comment">// Если параметров несколько,</span>
<span class="token comment">// то они перечисляются через запятую в круглых скобках.</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//Если параметр один, то он может быть без круглых скобок.</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> x <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Если параметров нет, то обязательно</span>
<span class="token comment">// должны быть пустые круглые скобки</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Hello! :]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>После символа <code>=&gt;</code> следует тело функции до точки с запятой. Здесь может быть два варианта - с использованием фигурных скобок и без их использования.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token comment">// Если фигурные скобки после символа =&gt;</span>
<span class="token comment">// стоят, значит необходимо явно задать то,</span>
<span class="token comment">// что должна вернуть функция - написать слово return и выражение.</span>
<span class="token comment">// Это называется явный возврат (explicit return)</span>
<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Если фигурных скобок нет, то</span>
<span class="token comment">// все содержимое тела функции возвращается.</span>
<span class="token comment">// Это называется неявный возврат (implicit return)</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span></code></pre><h3>Стрелочные функции и arguments</h3><p>В отличии от обычных функций, у стрелочных нет локальной переменной <code>arguments</code> содержащей все аргументы. Если необходимо собрать все аргументы в коллекцию используйте опертор <code>rest</code>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span></code></pre></section><section><h2 id="iife">IIFE</h2><p><code>IIFE (Immediately Invoked Function Expression)</code> - анонимное самовызывающееся выражение. Это выражение, одновременно объявляет функцию и осуществляет ее вызов.</p><p>Обращение к такой безымянной функции в дальнейшем, ссылка на которую отсутствует, невозможно. Главным назначением такого выражения является создание отдельной области видимости, чтобы избежать засорения внешней (обычно глобальной).</p><p>Для начала рассмотрим синтаксис.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token punctuation">(</span><span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// тело функции</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ES6 вариант</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// тело функции</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Так как <code>IIFE</code> создает свою область видимости, следующий пример вполне логичен.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-let">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-let">let</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-let">let</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 10</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 20</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 5</span>

<span class="token comment">// будет ошибка, y не объявлена в доступной области видимости</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught ReferenceError, y is not defined</span></code></pre><p>Присвоение <code>IIFE</code>в переменную запишет не саму функцию а результат ее выполнения, это часто используют для модульности кода, эту тему мы будем разбирать дальше в курсе.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> value <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 15</span></code></pre><p>В <code>IIFE</code> можно также передавать аргументы.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> value <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-return">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 13</span></code></pre><p>Немедленно вызываемые функции позволяют создавать компоненты для различных сайтов, сводя риск совпадений имен переменных к минимуму. Например баннер, использующий JavaScript, может быть помещен на миллионы сайтов, а значит переменные баннера не должны совпасть ни с одним из миллионов приложений JavaScript и хранящихся там переменных. Если функция была анонимной, то после выполнения этой функции к ней невозможно обратиться и переменные внутри нее гарантировано изолированы.</p><h3>Точка с запятой перед IIFE</h3><p>В коде проекта вы можете встретить запись <code>IIFE</code> следующего вида.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// тело функции</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Все хорошо, точка с запятой тут не лишняя. Это стандартный прием для надежной работы модуля с другим кодом, очень часто чужим. В статье <a href="http://shuvalov.info/2014/08/18/function-asi/" target="_blank"><strong>ASI и мистические знаки перед IIFE в JavaScript</strong> </a>, рассказывается в каких случаях необходимо ставить точку с запятой перед <code>IIFE</code>.</p></section><section><h2 id="guard-clause">Паттерн Guard Clause</h2><p><strong>Шаблон проектирования или паттерн (design pattern)</strong> в разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторой часто возникающей задачи или ситуации.</p><p>Давайте напишем функцию <code>printArray</code>которая будет перебирать массив и выводить в консоль его значения. На вход она будет получать аргумент <code>arr</code> - массив. В теле функции мы будем перебирать массив циклом <code>for...of</code> и печатать значения в консоль.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">printArray</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Используем прием программирования</span>
  <span class="token comment">// который называется Guard Clause</span>
  <span class="token comment">// Если arr не массив сразу прекратим выполнение функции</span>
  <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// если if не выполнился, то есть arr это массив,</span>
  <span class="token comment">// тогда переберем его</span>
  <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-let">let</span> value <span class="token keyword keyword-of">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">printArray</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 2, 3, 4</span>
<span class="token function">printArray</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5, 10, 15, 20</span>
<span class="token function">printArray</span><span class="token punctuation">(</span> <span class="token string">'some string'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></code></pre><p>С примерам применения паттерна <code>Guard Clause</code> <a href="http://www.informit.com/articles/article.aspx?p=1149121&amp;seqNum=11" target="_blank"><strong>ознакомьтесь в этой статье</strong> </a>.</p></section><section><h2 id="cb-fn">Функции обратного вызова</h2><p><strong>Функция обратного вызова (callback-функция)</strong> - это функция, переданная в другую функцию в качестве аргумента, где она вызывается внутри тела внешней функции.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">printString</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">getString</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-return">return</span> <span class="token string">"Some text"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">printString</span><span class="token punctuation">(</span>getString<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Some text"</span></code></pre><p>Пример посложнее, используем стрелочные функции.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token string">"Hello"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">printMessage</span> <span class="token operator">=</span> msg <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">fn</span><span class="token punctuation">(</span><span class="token string">"Mango"</span><span class="token punctuation">,</span> printMessage<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Hello Mango"</span></code></pre><p>Пример ниже демонстрирует, что callback-функции могут возвращать результат через какое-то время. Получив результат, функция, внутри которой находилась callback-функция, продолжит свое выполнение. Это свойство - ждать возврата вызова и только затем продолжить выполнение кода, является одним из самых сильных преимуществ языка JavaScript.</p><p>Функция обратного вызова применяется для обработки действий пользователя на странице, при вызове функций к определенному времени, при обработке запросов на сервер и др. Все это будет изучено на протяжении курса.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">showMessage</span> <span class="token operator">=</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> secretNumber <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-const">const</span> msg <span class="token operator">=</span> <span class="token function">cb</span><span class="token punctuation">(</span>secretNumber<span class="token punctuation">)</span>

  <span class="token comment">// alert не выполнится до тех пор,</span>
  <span class="token comment">// пока не выполнится строка кода выше</span>
  <span class="token comment">// и функция обратного вызова не вернет значение</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">guessNumber</span> <span class="token operator">=</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-const">const</span> userNumber <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span> <span class="token function">prompt</span><span class="token punctuation">(</span><span class="token string">'Введите число'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-return">return</span> num <span class="token operator">===</span> userNumber
    <span class="token operator">?</span> <span class="token string">"Поздравляем! Вы угадали секретное число"</span>
    <span class="token punctuation">:</span> <span class="token string">"Сожалеем! Вы не угадали секретное число"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">showMessage</span><span class="token punctuation">(</span>guessNumber<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section><h2 id="closure">Замыкания</h2><p>Некоторые языки программирования имеют что-то вроде области видимости или окружения, и этот механихм позволяет существовать замыканиям. Замыкания являются ключевой особенностью в JavaScript. Разработчикам понимание принципов работы тех или иных особенностей языка, даст больше осознанности в их применении.</p><p><strong>Замыкания</strong>  —  это функции, ссылающиеся на независимые (свободные) переменные. Другими словами, функция, определённая в замыкании, «запоминает» окружение, в котором она была создана.</p><p><strong>Независимые переменные</strong> — это все переменные, которые не были переданы как параметры и не были объявлены как локальные для замыкания.</p><p>Итого замыкание это всего лишь термин который описывает способность функции запоминать лексическое окружение, в котором она была создана и продолжать получать доступ к переменным из этого лексического окружения вне зависимости от того где она была вызвана.</p><p>Рассмотрим пример.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">createCounter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// Локальная «свободная» переменная value,</span>
  <span class="token comment">// которая доступна только в замыкании.</span>
  <span class="token keyword keyword-let">let</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-const">const</span> <span class="token function-variable function">incrementValue</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    value <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-return">return</span> incrementValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> counter1 <span class="token operator">=</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">counter1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token function">counter1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>

<span class="token keyword keyword-const">const</span> counter2 <span class="token operator">=</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">counter2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token function">counter2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></code></pre><p>В примере функция <code>createCounter</code> создаёт локальную переменную <code>value</code>, а также локальную функцию <code>incrementValue</code>, которая увеличивает значение <code>value</code> и выводит число в консоль.</p><p>Функция <code>incrementValue</code> не содержит собственной локальной переменной, но благодаря механизму замыкания ей доступна переменная из внешнего окружения функции <code>createCounter</code>. В результате она может пользоваться переменной <code>value</code>, созданной во время вызова функции <code>createCounter</code>, даже после того, как <code>incrementValue</code> будет возвращена из вызова <code>createCounter</code>.</p><p>Каждая функция имеет контекст выполнения, который включает в себя окружение, которое определяет набор переменных в функции и хранит ссылку на своё родительское окружение. Ссылка на родительское окружение делает все переменные из родительских областей видимости доступными для вложенных функций, независимо от того, была ли функция вызвана кодом внутри или снаружи данной области видимости.</p><p>Таким образом, функция запоминает окружение (область видимости), поскольку функция фактически сохраняет ссылку на окружение и тем самым удерживает в памяти таблицу переменных функции.</p><h3>Материалы по замыканиям</h3><p>Исчерпывающая статья по замыканиям от <a href="https://medium.freecodecamp.org/@preethikasireddy" target="_blank">Preethi Kasireddy</a>, и ее перевод по ссылкам ниже <strong>обязательна к прочтению</strong>.</p><ul><li>Оригинал - <a href="https://medium.freecodecamp.org/lets-learn-javascript-closures-66feb44f6a44" target="_blank">Let’s Learn JavaScript Closures</a></li><li>Перевод - <a href="https://medium.com/@sshambir/%D0%BE%D1%81%D0%B2%D0%B0%D0%B8%D0%B2%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-5b83267ef7d1" target="_blank">Осваиваем замыкания в Javascript</a></li></ul></section><section><h2 id="recursion">Рекурсия</h2><p><strong>Рекурсия</strong> – общая тема программирования, не относящаяся напрямую к JavaScript. Если вы разрабатывали на других языках или изучали программирование раньше в ВУЗе, то наверняка уже знаете, что это такое.</p><p>В теле функции могут быть вызваны другие функции для выполнения подзадач. Частный случай подвызова – когда функция вызывает сама себя, при этом она должна заботится о том, чтобы не переполнить стек вызовов. Это называется рекурсией.</p><p>Рекурсия используется для ситуаций, когда выполнение одной сложной задачи можно представить как некое действие в совокупности с решением той же задачи в более простом варианте.</p><p>Для начача напишем функцию возведения в степень используя обычный цикл. Имплементацию возьмем простую, топорную, в лоб. Все что надо сделать это умножить <code>base</code> на само себя <code>exponent</code> раз сохраняя результат.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">pow</span> <span class="token operator">=</span> <span class="token punctuation">(</span>base<span class="token punctuation">,</span> exponent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-let">let</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span><span class="token keyword keyword-let">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> exponent<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">*=</span> base<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword keyword-return">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span></code></pre><p>Теперь тоже самое выразим через рекурсию.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">pow</span> <span class="token operator">=</span> <span class="token punctuation">(</span>base<span class="token punctuation">,</span> exponent<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>exponent <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-return">return</span> base <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> exponent <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 8</span></code></pre><p>Примерно так математики определяют возведение в степень, и, возможно, это описывает концепцию более элегантно, чем цикл. Функция вызывает себя много раз с разными аргументами для достижения многократного умножения.</p><p>Однако, у такой реализации есть проблема – в обычной среде JavaScript она раз в 10 медленнее, чем версия с циклом. Проход по циклу выходит дешевле, чем вызов функции.</p><p>Дилемма «скорость против элегантности» довольно интересна. Есть некий промежуток между удобством для человека и удобством для машины. Любую программу можно ускорить, сделав её больше и замысловатее. От программиста требуется находить подходящий баланс.</p><p>В случае с первым возведением в степень, неэлегантный цикл довольно прост и понятен. Не имеет смысла заменять его рекурсией. Часто, однако, программы работают с такими сложными концепциями, что хочется уменьшить эффективность путём повышения читаемости.</p><p>Основное правило, которое уже не раз повторяли – не беспокойтесь насчёт быстродействия, пока вы точно не уверены, что программа тормозит. Если так, найдите те части, которые работают дольше всех, и меняйте там элегантность на эффективность.</p><p>Конечно, мы не должны сразу же полностью игнорировать быстродействие. Во многих случаях, как с возведением в степень, особой простоты от элегантных решений мы не получаем. Иногда опытный программист сразу видит, что простой подход никогда не будет достаточно быстрым.</p><p>Слишком много начинающих программистов хватаются за эффективность даже в мелочах. Результат получается больше, сложнее и часто не без ошибок. Такие программы дольше писать, а работают они часто не сильно быстрее.</p><p>Но рекурсия не всегда лишь менее эффективная альтернатива циклам. Некоторые задачи проще решить рекурсией. Чаще всего это обход нескольких веток дерева, каждая из которых может ветвиться.</p><h3>Материалы по рекурсии</h3><p>Рекурсия может не пригодится вам в начале изучения программирования, но со временем вы сталкнетесь с классом задач которые ожидают хотябы базового понимания рекурсии.</p><p>Для ознакомления с рекурсией:</p><ul><li><a href="https://youtu.be/Mv9NEXX1VHc" target="_blank">посмотрите это видео</a></li><li><a href="https://learn.javascript.ru/recursion" target="_blank">прочитайте эту статью</a></li></ul></section><a href="http://fecore.net.ua/javascript/pages/theory/module-03.html#main-nav" class="to-page-nav"></a></article></div></body></html>
<!DOCTYPE html>
<!-- saved from url=(0061)http://fecore.net.ua/javascript/pages/theory/module-06-1.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Module 6</title><link rel="stylesheet" href="./Module 6_files/styles.min.css"><script async="" src="./Module 6_files/scripts.min.js.Без названия"></script></head><body class="theory-page"><div class="wrapper"><article><header><nav class="table-of-contents" id="main-nav"><ol class="page-nav" id="page-nav"><li><a href="http://fecore.net.ua/javascript/pages/theory/module-06-1.html#oop-basics">Основы в ООП</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-06-1.html#proto-prop">Прототип объекта</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-06-1.html#fn-proto">Свойство Fn.prototype</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-06-1.html#inheritance">Наследование и конструкторы</a></li></ol></nav></header><section><h2 id="oop">Основы в ООП</h2><p>По своей сути разработка программного обеспечения это решение проблемы и достижение результата путем вычислений. Процесс разработки программного обеспечения сначала определяет проблему, а затем представляет собой решение. Объектно-ориентированное программирование является одним из нескольких основных подходов к процессу разработки.</p><p><strong>Объектно-ориентированное программирование (ООП)</strong> — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых содержит данные и методы для взаимодействия с ними.</p><p>Структура объекта делает его гибким в рамках программы. Объекты могут передавать информацию, вызывая и передавая данные другим методам объекта.</p><p>Идеологически, ООП это подход к программированию как к моделированию, решающий основную задачу структурного программирования: структурирование информации с точки зрения управляемости, что существенно улучшает контроль процесса моделирования. Это крайне важно при при реализации крупных проектов.</p><p>Появление объектно-ориентированного программирования стало результатом возросших требований к функционалу программ, когда описывать объект приходилось раз за разом в разных участках кода. Тогда и было введено понятие класса, параметры которого задавались единожды, а после в коде оставлялись только ссылки на класс, чтобы код самостоятельно «собрал» объект по «шаблону» класса.</p><p>Сейчас ООП так или иначе присутствует во всех языках, поэтому понимание его основ просто необходимо.</p><h3>Основные понятия ООП</h3><p>Представьте себе, что мы проектируем автомобиль. Мы знаем, что автомобиль должен содержать двигатель, 4 колеса и т.д. Ещё мы знаем, что автомобиль должен иметь возможность заводиться, набирать и сбавлять скорость. И, что самое главное, мы знаем, как взаимодействует двигатель и колёса, тоесть согласно каким законам взаимодействуют разные части машины.</p><h4>Класс</h4><p>Мы описываем все запчасти, из которых состоит наш автомобиль, а также то, каким образом эти запчасти взаимодействуют между собой. Кроме того, мы описываем, что должен сделать пользователь, чтобы машина затормозила, включился дальний свет фар. Результатом нашей работы будет некоторый эскиз. Мы только что разработали то, что в ООП называется класс.</p><p><strong>Класс</strong> – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).</p><p>С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов) и функций для работы с ними (методов). С точки зрения структуры программы, класс является сложным типом данных.</p><p>В нашем случае, класс будет отображать сущность – автомобиль. Атрибутами класса будут являться двигатель, четыре колеса и т.д. Методами класса будет «открыть дверь», «завести двигатель», «увеличить скорость» и т. п. Первые два метода доступны для выполнения другим классам (в частности, классу «Водитель»). Последний описывает взаимодействия внутри класса и не доступен пользователю.</p><div class="note"><p>Под «пользователем» подразумевается программист, который использует наш класс, включая нас самих. Человек, который является автором класса, назовем разработчик.</p></div><h4>Объект</h4><p>Мы спроектировали чертежи и машины, разработанные по ним, сходят с конвейера. Каждая из них точно повторяет чертеж. Все системы взаимодействуют именно так, как мы спроектировали. Но каждая машина уникальна. Они все имеют номер кузова и двигателя, но все эти номера разные, автомобили различаются цветом, отделкой салона и т.д. Эти автомобили, по сути, являются объектами нашего класса.</p><p><strong>Объект (экземпляр)</strong> – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом. Это то, что «создано» по «чертежу», то есть по описанию из класса.</p><p>Говоря простым языком, объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе. В данном примере, если класс – это некоторый абстрактный автомобиль из «мира идей», то объект – это конкретный автомобиль, стоящий у нас под окнами.</p><h4>Интерфейс</h4><p>Когда мы подходим к автомату с кофе или садимся за руль, мы начинаем взаимодействие с ними. Обычно, взаимодействие происходит с помощью некоторого набора элементов: щель для приёма монет, кнопка выбора напитка и отсек выдачи стакана в кофейном автомате; руль, педали, рычаг коробки переключения передач в автомобиле. Всегда существует некоторый ограниченный набор элементов управления, с которыми мы можем взаимодействовать.</p><p><strong>Интерфейс</strong> – это набор методов класса, доступных для использования другими классами.</p><p>Очевидно, что интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним. Хорошим примером интерфейса может служить приборная панель автомобиля, которая позволяет вызвать такие методы, как увеличение скорости, торможение, поворот, переключение передач, включение фар, и т.п. То есть все действия, которые может осуществить другой класс (в нашем случае – водитель) при взаимодействии с автомобилем.</p><p>При описании интерфейса класса очень важно соблюсти баланс между гибкостью и простотой. Класс с простым интерфейсом будет легко использовать, но будут существовать задачи, которые с помощью него решить будет не под силу. В то же время, если интерфейс будет гибким, то, скорее всего, он будет состоять из достаточно сложных методов с большим количеством параметров, которые будут позволять делать очень многое, но использование его будет сопряжено с большими сложностями и риском совершить ошибку, что-то перепутав.</p><h3>Парадигмы ООП</h3><h4>Абстракция</h4><p>Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерёнок в коробке передач или влияния формы кузова на скорость. Однако, руль, педали, указатель поворота он будет использовать регулярно.</p><p><strong>Абстрагирование</strong> – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.</p><p>Такой подход позволяет работать непосредственно с объектом, не вдаваясь в подробности, из чего же он состоит и как работает.</p><h4>Инкапсуляция</h4><p>Внутренние процессы работы автомобиля чертовски сложны. Но все эти действия скрыты от пользователя и позволяют ему крутить руль и нажимать на педаль газа, не задумываясь, что в это время происходит внутри. Именно сокрытие внутренних процессов, происходящих в автомобиле, позволяет эффективно его использовать даже новичкам. Это сокрытие в ООП носит название инкапсуляции.</p><p><strong>Инкапсуляция</strong> – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.</p><p>Инкапсуляция неразрывно связана с понятием интерфейса класса. По сути, всё то, что не входит в интерфейс, инкапсулируется (скрыто) в классе.</p><p>Это одновременно и облегчает конечному пользователю работу с программой, и защищает данные и само приложение от постороннего вмешательства. Пользователь может работать со всем функционалом через интерфейс, не задумываясь над тем, как программа работает.</p><p>Инкапсуляцию применяют:</p><ul><li>когда нужно сохранить некоторый участок кода без изменений со стороны пользователя</li><li>когда нужно ограничить доступ к коду - в связи с уникальностью используемых техник, которые автор хочет оставить «при себе»</li><li>когда изменение кода повлечёт за собой неработоспособность программы или её взлом</li></ul><h4>Наследование</h4><p>Представим себя инженерами автомобильного завода. Нашей задачей является разработка современного автомобиля. У нас уже есть предыдущая модель, которая отлично зарекомендовала себя. Всё бы хорошо, но времена и технологии меняются, а наш современный завод должен стремиться повышать удобство и комфорт выпускаемой продукции и соответствовать современным стандартам.</p><p>Нам необходимо выпустить целый модельный ряд автомобилей. Очевидно, что мы не собираемся проектировать новый автомобиль с нуля, а, взяв за основу предыдущее поколение, внесём ряд конструктивных изменений.</p><p>Очевидно, что все модификации будут иметь большинство свойств прежней модели. При этом каждая из моделей будет реализовать некоторую новую функциональность или конструктивную особенность. В данном случае, мы имеем дело с наследованием.</p><p><strong>Наследование</strong> – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.</p><div class="note"><p>Производный класс полностью удовлетворяет спецификации родительского, может иметь дополнительную функциональность. С точки зрения интерфейсов, каждый производный класс полностью реализует интерфейс родительского класса. Обратное не верно.</p></div><p>Действительно, в нашем примере мы могли бы произвести с новыми автомобилями все те же действия, что и со старым: увеличить или уменьшить скорость, повернуть, включить сигнал поворота. Однако, дополнительно у нас бы появилась возможность, например, включить противотуманные фонари.</p><p>Отсутствие обратной совместимости означает, что мы не должны ожидать от старой модели корректной реакции на такие действия, как включение автоматической самоскладывающейся крыши.</p><h4>Полиморфизм</h4><p>Любое обучение вождению не имело бы смысла, если бы человек, научившийся водить, скажем, Audi не мог потом водить BMW или любой другой автомобиль. С другой стороны, трудно представить человека, который смог бы нормально управлять автомобилем, в котором педаль газа находится левее педали тормоза, а вместо руля – джойстик.</p><p>Всё дело в том, что основные элементы управления автомобиля имеют одну и ту же конструкцию и принцип действия.</p><p>По сути, можно сказать, что все автомобили имеют один и тот же интерфейс, а водитель, абстрагируясь от сущности автомобиля, работает именно с этим интерфейсом. Независимо от того, каким образом будет реализовываться движение и внутреннее функционирование машины, интерфейс останется прежним.</p><p><strong>Полиморфизм</strong> – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. Позволяет переопределять в классах наследниках реализации методов базового класса.</p><p>Полиморфизм позволяет повысить процент повторного использования кода и сократить тем самым размер программы и временные затраты на её написание.</p></section><section><h2 id="proto-prop">Прототип объекта</h2><p>Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном выступает специальное скрытое свойство <code>[[Prototype]]</code>. Браузеры отображают его как <code>__proto__</code>.</p><h3>Прототип</h3><p>Если один объект имеет специальную ссылку в поле <code>__proto__</code> на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте на который ссылается <code>__proto__</code>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span> eats<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> dog <span class="token operator">=</span> <span class="token punctuation">{</span> barks<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

dog<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> animal<span class="token punctuation">;</span>

<span class="token comment">// в dog можно найти оба свойства</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> dog<span class="token punctuation">.</span>barks <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> dog<span class="token punctuation">.</span>eats <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre><p>Первый <code>log</code> работает очевидным образом – он выводит свойство <code>barks</code> объекта <code>dog</code>. Второй <code>log</code> хочет вывести <code>dog.eats</code>, ищет его в самом объекте <code>dog</code>, не находит – и продолжает поиск в объекте по ссылке из <code>dog.__proto__</code>, то есть, в данном случае, в <code>animal</code>.</p><div class="note"><p>Объект, на который указывает ссылка в <code>__proto__</code>, называется <code>прототипом</code>. В данном случае получилось, что <code>animal</code> является прототипом для <code>dog</code>.</p></div><p>Если мы добавим объекту <code>dog</code> свойство <code>eats</code> и присвоим ему <code>false</code>, то результат будет следующим.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span> eats<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> dog <span class="token operator">=</span> <span class="token punctuation">{</span> barks<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> eats<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

dog<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> animal<span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> dog<span class="token punctuation">.</span>barks <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> dog<span class="token punctuation">.</span>eats <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false, свойство взято из dog</span></code></pre><p>Другими словами, прототип – это <strong>резервное хранилище свойств и методов</strong> объекта, автоматически используемое при поиске. У объекта, который является <code>__proto__</code>, может быть свой <code>__proto__</code>, у того – свой, и так далее. При этом свойства будут искаться по цепочке наследования.</p><p>Если вы будете читать спецификацию ECMAScript – свойство <code>__proto__</code> обозначено в ней как <code>[[Prototype]]</code>. Двойные квадратные скобки здесь важны, чтобы не перепутать его с совсем другим свойством, которое называется <code>prototype</code>.</p><div class="warn"><p><a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/proto" target="_blank"><strong>Предупреждение</strong> </a>- изменение поля <code>__proto__</code> "вручную" является грубым нарушением, и было приведено лишь для наглядного, более визуального примера механизма прототипного наследования.</p></div><h3>Object.create</h3><p>Для того чтобы "правильно" задать прототип объекта, можно использовать метод <code>Object.create(obj)</code>, передав параметру <code>obj</code> ссылку на объект который мы хотим сделать прототипом создаваемого объекта.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span> eats<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> dog <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span>
dog<span class="token punctuation">.</span>barks <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> key <span class="token keyword keyword-in">in</span> dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// barks, eats</span>
<span class="token punctuation">}</span></code></pre><p>На рисунке видно то, что называется <strong>цепочкой прототипов (prototype chain)</strong>. В свойство <code>__proto__</code> объекта <code>dog</code> записана ссылка на объект <code>animal</code>, в свойство <code>__proto__</code> которого, в свою очередь, записана ссылка на родителя всех объектов JavaScript - <code>Object</code>. Именно поэтому мы можем вызывать методы вроде <code>hasOwnProperty</code> или <code>toString</code>, хотя мы не определяли их для <code>dog</code> или <code>animal</code>.</p><img src="./Module 6_files/proto-chain.png" alt="proto-chain"><p>Схематически цепь прототипов выглядит следующим образом.</p><img src="./Module 6_files/prototype-chain.png" alt="prototype-chain"><p>Механизм поиска свойства работает <strong>до первого совпадения</strong>. Компилятор ищет свойство по имени в объекте, если не находит, то обращается к свойству <code>[[Prototype]]</code>, т.е. переходит по ссылке к объекту-прототипу, а затем и прототипу прототипа. В конце этой цепочки находится <code>null</code>. В случае первого совпадения механизм вернет значение свойства. Если механизм доберется до <code>null</code>, то вернет <code>undefined</code>.</p><h3>Объект без прототипа</h3><p>Бывают задачи хранения в объекте произвольных значений по ключу, как коллекцию. При поиске в этой коллекции мы найдём не только указанные поля, но и встроенные методы.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Mango'</span><span class="token punctuation">,</span>
  age<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>toString<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function</span></code></pre><p>Это может приводить к ошибкам. Чтобы этого избежать, мы можем создавать объект с помощью метода <code>Object.create(obj)</code>, передав параметру <code>obj</code> значение <code>null</code>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> user <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword keyword-null">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
user<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Mango'</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mango</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>toString<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span></code></pre><p>Объект, создаваемый при помощи <code>Object.create(null)</code> не имеет прототипа, а значит в нём нет лишних свойств. Для коллекции – как раз то, что надо.</p><h3>hasOwnProperty</h3><p>После того как мы узнали о том как происходит поиск свойств объекта, должно стать понятно, почему цикл <code>for..in</code> не делает различия между свойствами объекта и его прототипа.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span> eats<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> dog <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span>
dog<span class="token punctuation">.</span>barks <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> key <span class="token keyword keyword-in">in</span> dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// barks, eats</span>
<span class="token punctuation">}</span></code></pre><p>Именно поэтому мы используем метод <code>obj.hasOwnProperty(prop)</code>, который возвращает <code>true</code>, если свойство <code>prop</code> принадлежит самому объекту <code>obj</code>, а не его прототипу, иначе <code>false</code>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> animal <span class="token operator">=</span> <span class="token punctuation">{</span> eats<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> dog <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span><span class="token punctuation">;</span>
dog<span class="token punctuation">.</span>barks <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span><span class="token keyword keyword-const">const</span> key <span class="token keyword keyword-in">in</span> dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dog<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// barks</span>
<span class="token punctuation">}</span></code></pre></section><section><h2 id="fn-proto">Свойство Fn.prototype</h2><p>Мы уже знаем что такое прототип, свойство <code>__proto__</code>, как происходит поиск отсутствующих свойств объекта по цепочке и методы указания прототипа для одного объекта. Но в реальных проектах объекты обычно создаются функцией-конструктором через <code>new</code>. Давайте разберемся как происходит указание прототипа в этом случае.</p><h3>Свойство prototype</h3><p>Создадим функцию-конструктор <code>Guest</code> которая будет создавать нам экземпляры объектов гостя отеля.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">Guest</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> room<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>room <span class="token operator">=</span> room<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>Так как функция это тоже объект, как бы странно это не звучало, <strong>у каждой</strong> функции есть скрытое свойство <code>prototype</code>, в котором изначально хранится объект с единственным полем <code>constructor</code>, указывающим на саму функцию-конструктор, об этом позже.</p><p>Свойство <code>Function.prototype</code>:</p><ul><li>является <strong>объектом</strong></li><li>в него можно записывать свойства и методы</li><li>cвойства и методы prototype будут <strong>доступны по ссылке</strong></li><li>cвойство prototype <strong>есть у всех функций</strong> JavaScript</li><li>у свойства prototype есть метод <strong>constructor</strong></li></ul><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">Guest</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> room<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>room <span class="token operator">=</span> room<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Guest<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {constructor: ƒ}</span></code></pre><p>При создании объекта через <code>new</code>, в его поле <code>__proto__</code> записывается ссылка на объект хранящийся в свойстве <code>prototype</code> функции-конструктора.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">Guest</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> room<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>room <span class="token operator">=</span> room<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-const">const</span> mango <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Guest</span><span class="token punctuation">(</span><span class="token string">'Mango'</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mango<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><img src="./Module 6_files/new-operator.png" alt="new-operator"> <img src="./Module 6_files/mango-prototype.png" alt="mango-prototype"><p>Эту особенность мы можем использовать для того, чтобы добавлять в объект <code>protopype</code> методы, которые будут доступны по ссылке абсолютно всем объектам созданным через <code>new Guest(...)</code>.</p><p>Причем если мы создадим миллион экземпляров гостя, набор методов будет не у каждого свой, а всего один, общий, хранящийся в объекте свойства <code>Guest.prototype</code> и доступный всем потомкам по ссылке, которая записывается в поле <code>__proto__</code> объекта при создании, благодаря прототипному наследованию и цепочке прототипов.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">Guest</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> room<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>room <span class="token operator">=</span> room<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Guest<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">showGuestInfo</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, room: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>room<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> mango <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Guest</span><span class="token punctuation">(</span><span class="token string">'Mango'</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-const">const</span> poly <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Guest</span><span class="token punctuation">(</span><span class="token string">'Poly'</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

mango<span class="token punctuation">.</span><span class="token function">showGuestInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name: Mango, room: 28</span>
poly<span class="token punctuation">.</span><span class="token function">showGuestInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// name: Poly, room: 36</span></code></pre><img src="./Module 6_files/mango-poly-inst.png" alt="mango-poly-inst"><p>Свойство <code>prototype</code> может передать по ссылке свое значение всем потомкам функции-конструктора. Если мы изменим значение у свойства <code>prototype</code> то это новое значение получат и все свойства, имеющие ссылку на объект <code>prototype</code>.</p><h3>Свойство constructor</h3><p>Было упоминание того, чтобы по умолчанию свойство <code>protopype</code> уже содержит поле <code>constructor</code>.</p><p>Запишем это поле явно:</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">Guest</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> room<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>room <span class="token operator">=</span> room<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Guest<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Guest
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>В коде выше мы создали Guest.prototype вручную, но ровно такой же – генерируется автоматически. А свойство <code>constructor</code> содержит ссылку на саму функцию-конструктор.</p><img src="./Module 6_files/constructor.png" alt="constructor"><p>Свойство <code>[[Prototype]]</code> называют скрытым свойством потому что прямой доступ к нему ограничен средствами самого языка. Метод, который делает запись ссылки в объект в момент создания имеет такой доступ. Находится этот метод в объекте <code>prototype</code> функции и называется <code>consrtuctor</code>.</p><p><a href="http://yehudakatz.com/2011/08/12/understanding-prototypes-in-javascript/" target="_blank"><strong>Understanding "Prototypes" in JavaScript</strong></a></p></section><section><h2 id="inheritance">Наследование и конструкторы</h2><p>Конструктор это функция для создания объектов по шаблону. Оператор <code>new</code> создает объект и вызывает функцию-конструктор в контексте этого объекта. На выходе получаем объект с полями указанными в функции-конструкторе через <code>this</code> и полем <code>[[Prototype]]</code> (__proto__ в браузерах) которое содержит ссылку на поле <code>prototype</code> функции-конструктора.</p><p>Иногда случаются задачи когда объекты созданные функцией-конструктором должны также иметь доступ к полям и методам прототипа объявленым в другой функции-конструкторе.</p><p>Например мы пишет игру в стиле RPG, и нам необходимо подготовить логику для классовой системы персонажей, где есть общий конструктор <strong>Hero</strong> с дефолтными полями общими для всех классов, вроде имени, здоровья, количества опыта и т. п. После чего нам необходимо сделать конструкторы для <strong>Warrior</strong> и <strong>Wizard</strong>, результирующие экземпляры которых также должны иметь доступ к полям <strong>Hero</strong> но в тоже время иметь свои собственные.</p><p>Давайте реализуем это используя прототипное наследование и функции-конструкторы.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">Hero</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> xp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>xp <span class="token operator">=</span> xp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
  Теперь у нас есть конструктор базового класса героя,
  добавим в prototype какой-то метод.
*/</span>
Hero<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">gainXp</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> gained </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>amount<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> experience points`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>xp <span class="token operator">+=</span> amount<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> mango <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token string">'Mango'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mango<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hero { name: 'Mango', xp: 1000 }</span>

<span class="token comment">// Так как mango это экземпляр Hero,</span>
<span class="token comment">// то ему доступны методы из Hero.prototype</span>
mango<span class="token punctuation">.</span><span class="token function">gainXp</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Mango gained 500 experience points</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mango<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hero { name: 'Mango', xp: 1500 }</span>
</code></pre><p>Далее необходимо создать класс <strong>Warrior</strong>, так как нет смысла добавлять в <strong>Hero</strong> абсолютно все поля всех классов. Поэтому нам необходимо создать еще функцию-конструктор но при этом она должна быть как-то связана с <strong>Hero</strong>.</p><p>Для решения этой задачи мы можем использовать метод <code>call()</code>, вызвав функцию-конструктор <strong>Hero</strong> и передав ей объект создающийся в <strong>Warrior</strong> как контекст.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">Warrior</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> xp<span class="token punctuation">,</span> weapon<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/*
    Во время выполнения функции Warrior вызываем
    функцию Hero в контексте объекта создающегося
    в Warrior, а так же передаем аргументы для
    инициализации полей this.name и this.xp

    this в данном случае это наш будущий экземпляр Warrior
  */</span>
  Hero<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> xp<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Тут добавляем новое свойство - оружие</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>weapon <span class="token operator">=</span> weapon<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Сразу добавим метод для атаки в prototype воина</span>
Warrior<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">attack</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> attacks with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>weapon<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> poly <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Warrior</span><span class="token punctuation">(</span><span class="token string">'Poly'</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">'sword'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>poly<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Warrior {name: "Poly", xp: 200, weapon: "sword"}</span>

poly<span class="token punctuation">.</span><span class="token function">attack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Poly attacks with sword</span></code></pre><p>Вроде все хорошо, но что произойдет если мы попробуем вызвать у <code>poly</code> метод <code>gainXp()</code>, который обьявлен на <code>Hero.prototype</code>? - будет ошибка</p><pre class=" language-javascript"><code class=" language-javascript">poly<span class="token punctuation">.</span><span class="token function">gainXp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Uncaught TypeError: poly.gainXp is not a function</span></code></pre><p>Дело в том что поля из <code>Hero.prototype</code> не добавляются в цепочку прототипов по умолчанию. Необходимо явно укзать связь поля <code>Warrior.prototype</code> и <code>Hero.prototype</code>. Сделать это очень легко, но важно поминать как и почему это работает.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token comment">/*
  Используем Object.create() для того чтобы изначально
  записать в Warrior.prototype пустой объект, в __proto__ которого
  будет ссылка на Hero.prototype.

  Это необходимо сделать до того как добавлять. какие-либо методы
*/</span>

Warrior<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Hero<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Теперь добавим метод для атаки</span>
Warrior<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">attack</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> attacks with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>weapon<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// попробуем теперь</span>
poly<span class="token punctuation">.</span><span class="token function">gainXp</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Poly gained 300 experience points</span></code></pre><p>В результате мы получили цепочку прототипов. При вызове <code>poly.gainXp()</code>, идет поиск поля <code>gainXp</code> в самом объекте <code>poly</code>, если такового нет, тогда идет поиск в том объекте который указан в поле <code>poly.__proto__</code>, это ссылка на <code>Warrior.ptototype</code>.</p><p>Eсли же его нету и там, то поиск идет в поле <code>__proto__</code> того объекта что указан в <code>poly.__proto__</code>, то есть в <code>poly.__proto__.__proto__</code>, а это ссылка на <code>Hero.prototype</code>, где есть метод <code>gainXp</code>.</p><p>Полный код примера:</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-function">function</span> <span class="token function">Hero</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> xp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>xp <span class="token operator">=</span> xp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Hero<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">gainXp</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span>amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> gained </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>amount<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> experience points`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>xp <span class="token operator">+=</span> amount<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-function">function</span> <span class="token function">Warrior</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> xp<span class="token punctuation">,</span> weapon<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Hero<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword keyword-this">this</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> xp<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>weapon <span class="token operator">=</span> weapon<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Warrior<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Hero<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

Warrior<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">attack</span> <span class="token operator">=</span> <span class="token keyword keyword-function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> attacks with </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>weapon<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> poly <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Warrior</span><span class="token punctuation">(</span><span class="token string">'Poly'</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">'sword'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><a href="https://www.digitalocean.com/community/tutorials/understanding-prototypes-and-inheritance-in-javascript" target="_blank" rel="noopener">Understanding Prototypes and Inheritance in JavaScript</a></li><li><a href="https://hackernoon.com/inheritance-in-javascript-21d2b82ffa6f" target="_blank" rel="noopener">Inheritance in JavaScript</a></li></ul></section></article><a href="http://fecore.net.ua/javascript/pages/theory/module-06-1.html#main-nav" class="to-page-nav"></a></div></body></html>
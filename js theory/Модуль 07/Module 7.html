<!DOCTYPE html>
<!-- saved from url=(0061)http://fecore.net.ua/javascript/pages/theory/module-07-1.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Module 7</title><link rel="stylesheet" href="./Module 7_files/styles.min.css"><script async="" src="./Module 7_files/ei.js.Без названия"></script><script async="" src="./Module 7_files/scripts.min.js.Без названия"></script></head><body class="theory-page"><div class="wrapper"><article><header><nav class="table-of-contents" id="main-nav"><ol class="page-nav" id="page-nav"><li><a href="http://fecore.net.ua/javascript/pages/theory/module-07-1.html#dom">Объектная Модель Документа</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-07-1.html#html-and-dom">HTML-документ и DOM</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-07-1.html#page-build">Процесс построения веб-страницы</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-07-1.html#dom-nav">Навигация по DOM</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-07-1.html#dom-search">Поиск DOM-узлов</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-07-1.html#attr-and-props">Атрибуты и DOM-свойства</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-07-1.html#dom-work">Работа с DOM-узлами</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-07-1.html#optimization">Оптимизация работы с DOM</a></li></ol></nav></header><section><h2 id="dom">Объектная Модель Документа</h2><p><strong>DOM (Document Object Model)</strong> - это межплатформенный и независимый от языка интерфейс прикладного программирования, и может использоваться с любым языком.</p><p>DOM обрабатывает HTML-документ как древовидную структуру, в которой каждый узел является объектом представляющим часть документа, который имеет свойства и методы. Объекты могут управляться программно, и любые видимые изменения, происходящие в результате, могут затем отражаться в документе.</p><p>Сам по себе JavaScript не предусматривает работы с браузером. Он вообще не знает про HTML. Каждый элемент в документе - весь документ в целом, заголовок, ссылка, абзац - это части DOM для этого документа, поэтому все они доступны и могут изменяться с помощью DOM и JavaScript.</p><ul><li><a href="https://frontender.info/dom/" target="_blank">Что такое DOM?</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank">What is the DOM? (MDN)</a></li></ul></section><section><h2 id="html-and-dom">HTML-документ и DOM</h2><p><strong>DOM</strong> – это представление документа в виде дерева объектов, доступное для изменения через JavaScript</p><p>Согласно DOM-модели документ является иерархией. Каждый тег образует отдельный элемент-узел, каждый фрагмент текста - текстовый элемент, таким образом HTML-документ представляет собой иерархическое дерево.</p><p>Это означает, что у каждого элемента (кроме корневого) есть только один родитель, т.е. элемент, внутри которого он располагается. У корневого раздела родитель отсутствует. Это дерево образуется за счет вложенной структуры тегов и текстовых элементов.</p><img src="./Module 7_files/dom-tree.png" alt="dom tree"><h3>DOM</h3><p>HTML описывает структуру веб-страницы. Чтобы понять HTML-документ, браузеру сначала нужно преобразовать его в формат который он понимает - DOM. У движка браузера есть специальный фрагмент кода, называемый <code>парсером</code>, который используется для преобразования данных из одного формата в другой. HTML-парсер преобразует данные из HTML в DOM.</p><p>В HTML вложенность определяет отношения родитель-ребенок между элементами. В DOM, объекты связаны в древовидной структуре данных, фиксируя эти отношения. Каждый тег HTML представлен узлом дерева (DOM-узел).</p><p>Браузер строит DOM постепенно, как только приходят первые фрагменты кода, он начинает разбирать HTML, добавляя узлы в древовидную структуру.</p><figure><img src="./Module 7_files/dom-parse.gif" alt="dom parsing"><figcaption>Иллюстрация работы HTML-парсера</figcaption></figure><p>DOM выполняет две роли: является объектным представлением HTML-документа, и действует как интерфейс, соединяющий страницу с внешним миром, например JavaScript.</p><p>Когда вы вызываете <code>document.getElementById()</code>, возвращаемый элемент является DOM-узлом. Каждый DOM-узел имеет множество методов, которые вы можете использовать.</p><figure><img src="./Module 7_files/js-eng.gif" alt="js engine and html parser"><figcaption>Иллюстрация работы JavaScript движка</figcaption></figure><h3>CSSOM</h3><p>Стили CSS, преобразуются в CSSOM - объектную модель CSS. Это похоже на DOM, но для CSS. В отличие от DOM, он не может быть построен постепенно. Поскольку правила CSS могут переопределять друг друга, движок браузера должен выполнять сложные вычисления, чтобы выяснить, как CSS-код применяется к DOM.</p><figure><img src="./Module 7_files/css-parse.png" alt="css parser"><figcaption>Иллюстрация работы CSS-парсера</figcaption></figure><h3>Пример</h3><p>Давайте на примере составим дерево HTML-документа.</p><pre class=" language-markup"><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>some text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>item 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>item 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>item 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre><figure><img src="./Module 7_files/tree.png" alt="tree"><figcaption>Визуальное представление иерархии дерева документа</figcaption></figure><p>В этом дереве выделено два типа узлов:</p><ul><li><strong>Узлы-элементы (element node)</strong> - образуются тегами, естественным образом одни узлы вложены в другие. Структура дерева образована исключительно за счет них.</li><li><strong>Текстовые узлы (text node)</strong> - образуются текстом внутри элементов. Текстовый узел содержит исключительно строку текста и не может иметь потомков, то есть он всегда на самом нижнем уровне.</li></ul><p><strong>Пробелы и переносы строки</strong> – это тоже текст, полноправные символы, которые учитываются в DOM. Из этого правила есть исключения: пробелы до <code>head</code> по стандарту игнорируются, а любое содержимое после <code>body</code> не создаёт узла, браузер переносит его внутрь, в конец <code>body</code>.</p><p><a href="http://yoksel.github.io/html-tree/" target="_blank">Генератор DOM-дерева</a></p></section><section><h2 id="page-build">Процесс построения веб-страницы</h2><p>Когда браузер создает DOM, если он встречает тег <code>script</code> в HTML, он должен выполнить его сразу. Если скрипт является внешним, он должен сначала загрузить скрипт.</p><p>По умолчанию, чтобы выполнить скрипт, построение DOM приостанавливается, и возобновляется только после того, как JavaScript-движок выполнил скрипт.</p><img src="./Module 7_files/build-1.png" alt="parser blocking script"><p>Почему построение DOM приостановается? Скрипты могут изменять как HTML, так и его продукт - DOM, добавляя узлы. Скрипты могут также запрашивать что-то о DOM, и если это происходит, когда DOM все еще строится, он может вернуть неожиданные результаты.</p><p>JavaScript блокирует построение DOM, поскольку он может модифицировать документ. CSS не может изменить документ, поэтому кажется, что нет причин для его блокировки, правильно?</p><p>Однако, если скрипт запрашивает информацию (о стиле), которая еще не была проанализирована? Браузер не знает, что собирается выполнить скрипт - он может запросить что-то вроде фонового цвета узла DOM, который зависит от таблицы стилей.</p><img src="./Module 7_files/html-css-js.png" alt="parsing"><p>Из-за этого CSS может блокировать разбор HTML в зависимости от порядка внешних таблиц стилей и сценариев в документе. Если перед скриптами в документе есть внешние таблицы стилей, конструкция объектов DOM и CSSOM может мешать друг другу. Когда синтаксический анализатор попадает в тег сценария, конструкция DOM не может продолжаться до тех пор, пока JavaScript не завершит выполнение, и JavaScript не будет выполнен до тех пор, пока CSS не будет загружен, проанализирован и не будет доступен CSSOM.</p><img src="./Module 7_files/build-2.png" alt="parser blocking css"><p>Еще одна вещь, о которой следует помнить, заключается в том, что даже если CSS не блокирует конструкцию DOM, он блокирует рендеринг. Браузер ничего не отобразит, пока не будет DOM и CSSOM. Это связано с тем, что страницы без CSS часто непригодны для использования.</p><p>Если браузер показал беспорядочную страницу без CSS, а через несколько мгновений стилизованную, это называется <code>Flash of Unstyled Content</code>.</p><p>Внезапные смещения содержимого и визуальные изменения плохо влияют на user experience. Чтобы обойти эти проблемы, вы должны стремиться как можно скорее доставить CSS. Вспомните правило «стили наверху, сценарии внизу»? Теперь вы знаете, зачем делать именно так 😉</p><h3>Атрибуты defer и async</h3><p>Синхронные скрипты блокирующие парсер, это проблема. И не все скрипты одинаково важны для пользователей, например, для отслеживания и аналитики. Решение? Асинхронная загрузка этих менее важных скриптов.</p><p>Атрибуты <code>defer</code> и <code>async</code> были введены, чтобы дать разработчикам возможность рассказать браузеру, какие скрипты обрабатывать асинхронно.</p><p>Оба атрибута сообщают браузеру, что он может продолжить разбор HTML при загрузке сценария «в фоновом режиме», а затем выполнить скрипт после его загрузки. Таким образом, загрузка скриптов не блокирует конструкцию DOM и рендеринг страниц. Результат: пользователь может видеть страницу до того, как все сценарии завершили загрузку.</p><p>Разница между ними - это тот момент, когда загруженые скрипты начинают выполняться.</p><p>Выполнение <code>defer</code> скриптов начинается после завершения парсинга, но перед событием <code>DOMContentLoaded</code>. Это гарантирует, что скрипты будут выполняться в том порядке, в котором они отображаются в HTML, и не будут блокировать синтаксический анализатор.</p><img src="./Module 7_files/defer.png" alt="defer"><p><code>async</code> выполняется при первой возможности после завершения загрузки и перед событием загрузки окна. Это означает, что возможно скрипты не выполняются в том порядке, в котором они отображаются в HTML. Это также означает, что они могут прервать создание DOM.</p><p>Где бы они ни были указаны, асинхронные скрипты загружаются с низким приоритетом. Они часто загружаются после всех других скриптов, не блокируя создание DOM. Однако, если <code>async</code> скрипт завершает загрузку раньше, его выполнение может блокировать создание DOM и все синхронные скрипты, которые впоследствии завершают загрузку.</p><img src="./Module 7_files/async.png" alt="" style="width: 80%"><h3>Атрибут preload</h3><p><code>async</code> и <code>defer</code> отлично подходят, если вы хотите отложить обработку некоторых скриптов, но как быть с контентом который важен для пользователя? Общая цель состоит в том, чтобы сначала предоставить CSS, поскольку он блокирует рендеринг. Синхронные скрипты всегда будут иметь более высокий приоритет, чем асинхронный. Изображения, видимые в первоначальной области окна просмотра, должны быть загружены до тех, что находятся ниже видимого контента. А есть также шрифты, видеоролики, SVG ... В общем - это сложно.</p><p>Вы как разработчик, знаете какие ресурсы являются наиболее важными для рендеринга страницы. Некоторые из них часто находятся в CSS или скриптах, и браузеру может потребоваться некоторое время, прежде чем он их даже обнаружит.</p><p>Для этих важных ресурсов вы можете использовать <code>&lt;link rel="preload"&gt;</code> для того чтобы сообщить браузеру о том, что вы хотите загрузить эти ресурсы как можно быстрее.</p><pre class=" language-markup"><code class=" language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>very_important.js<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>script<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span></code></pre><p>Вы можете указать к загрузке почти что угодно, и атрибут <code>as</code> укажет браузеру что тот будет загружать. Некоторые из возможных значений: <code>script</code>, <code>style</code>, <code>image</code>, <code>font</code>, <code>audio</code>, <code>video</code>.</p><div class="note"><p>На данный момент функция предварительной загрузки имеет ограниченную поддержку, так как браузеры еще только начинают включать ее, но вы <a href="https://caniuse.com/#search=preload" target="_blank">можете проверить текущий уровень поддрежки</a> .</p></div></section><section><h2 id="dom-nav">Навигация по DOM</h2><p>Согласно стандарту W3C, в HTML-документе все является узлом:</p><ul><li>Весь документ является узлом <code>document</code></li><li>Каждый элемент HTML является узлом <code>element</code></li><li>Текст внутри элементов HTML - это <code>text node</code></li><li>Все комментарии - <code>comment node</code></li></ul><img src="./Module 7_files/dom-trav-intro.gif" alt="dom-trav"><p>DOM предоставляет широкий спектр возможностей при работе с HTML-элементом и его содержимым, но для этого нужно сначала получить необходимый элемент.</p><p>Доступ к DOM начинается с объекта <code>document</code>. Из него можно добраться до любых узлов. Все узлы в дереве доступны для манипуляции с помощью JavaScript.</p><p>Узлы в HTML дереве имеют иерархическое отношение друг к другу. Термины <code>parent (родитель)</code>, <code>child (ребенок)</code> и <code>sibling (сосед)</code> используются для описания отношений.</p><ul><li>В дереве узлов верхний узел называется <code>корневым (root node)</code></li><li>Каждый узел имеет только одного родителя, кроме <code>root node</code>, который не имеет родителя</li><li>У узла может быть сколько угодно детей</li><li>Соседи - это узлы с одним и тем же родителем</li><li>Дочерние элементы – элементы, которые лежат непосредственно внутри данного. Например, внутри <code>html</code> обычно лежат <code>head</code> и <code>body</code></li><li>Потомки – все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть, всё поддерево DOM.</li></ul><table><caption>Вы можете использовать следующие свойства для навигации между узлами.</caption><thead><tr><th>Синтаксис</th><th>Описание</th></tr></thead><tbody><tr><td><code>elem.parentNode</code></td><td>Выберет родителя elem</td></tr><tr><td><code>elem.childNodes</code></td><td>Псевдо-массив хранит все дочерние элементы, включая текстовые.</td></tr><tr><td><code>elem.children</code></td><td>Псевдо-массив хранит только дочерние узлы-элементы, то есть соответствующие тегам.</td></tr><tr><td><code>elem.firstChild</code></td><td>Выберет первый дочерний элемент внутри elem, включая текстовые узлы.</td></tr><tr><td><code>elem.firstElementChild</code></td><td>Выберет первый дочерний узел-элемент внутри elem.</td></tr><tr><td><code>elem.lastChild</code></td><td>Выберет последний дочерний элемент внутри elem, включая текстовые узлы.</td></tr><tr><td><code>elem.lastElementChild</code></td><td>Выберет последний дочерний узел-элемент внутри elem.</td></tr><tr><td><code>elem.previousSibling</code></td><td>Выберет элемент "слева" от elem (его предыдущего соседа)</td></tr><tr><td><code>elem.previousElementSibling</code></td><td>Выберет узел-элемент "слева" от elem (его предыдущего соседа)</td></tr><tr><td><code>elem.nextSibling</code></td><td>Выберет элемент "справа" от elem (его следующего соседа)</td></tr><tr><td><code>elem.nextElementSibling</code></td><td>Выберет узел-элемент "справа" от elem (его предыдущего соседа)</td></tr></tbody></table><div class="note"><p>DOM-коллекции, такие как <code>childNodes</code> и <code>children</code>, не настоящие массивы. В них нет методов массивов, таких как <code>map</code>, <code>push</code>, <code>pop</code> и других.</p></div><figure><img src="./Module 7_files/traversing.png" alt="traversing the tree"><figcaption>Иллюстрация навигации по списку</figcaption></figure><p>Давайте выразим в коде то, что указано на иллюстрации выше.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_pWgGPM" src="./Module 7_files/pWgGPM.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-dom-traversing" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section><section><h2 id="dom-search">Поиск DOM-узлов</h2><p>Итак, мы уже знаем что DOM-узел это объект. У него есть методы и свойства. Давайте ближе познакомимся и научимся работать с DOM.</p><h3>elem.querySelector*</h3><pre class=" language-javascript"><code class=" language-javascript">elem<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span></code></pre><p>Возвращает псевдомассив всех элементов внутри <code>elem</code>, удовлетворяющие CSS-селектору <code>selector</code>. Если ничего не найдено вернет пустой массив. Это один из самых часто используемых и полезных методов при работе с DOM. Псевдо-классы в <code>selector</code>, такие как <code>:hover</code> и <code>:active</code>, также поддерживаются.</p><pre class=" language-javascript"><code class=" language-javascript">eelem<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span></code></pre><p>Возвращает не все, а только первый элемент, соответствующий CSS-селектору <code>selector</code>. Иначе говоря – ищется только первое совпадение, после чего поиск прекращается. Если ничего не найдено, вернет <code>null</code>. Этот метод используется когда мы заведомо знаем, что подходящий элемент только один.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_NvVpMw" src="./Module 7_files/NvVpMw.html" scrolling="no" frameborder="0" height="350" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-new-selectors  " class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p>В 99.99% ситуаций достаточно <code>querySelector</code> и <code>querySelectorAll</code>. Хотя более специализированные методы getElement* работают чуть быстрее, разница в миллисекунду-другую редко играет роль.</p><h3>До querySelector*</h3><p>До появления группы <code>querySelector*</code> использовались следующие методы.</p><table><thead><tr><th>Синтаксис</th><th>Описание</th></tr></thead><tbody><tr><td><code>document.getElementById(id)</code></td><td>Выбирает дом узел по идентификатору <code>id</code>. Возвращает ссылку на найденый DOM-узел или <code>null</code> если ничего не найдено.</td></tr><tr><td><code>elem.getElementsByTagName(tag)</code></td><td>Ищет все элементы с заданным тегом <code>tag</code> внутри элемента <code>elem</code> и возвращает их в виде списка</td></tr><tr><td><code>elem.getElementsByClassName(cls)</code></td><td>Возвращает коллекцию элементов с классом <code>cls</code>. Находит элемент и в том случае, если у него несколько классов, а искомый – один из них.</td></tr></tbody></table><div class="cp_embed_wrapper"><iframe id="cp_embed_YxbZpz" src="./Module 7_files/YxbZpz.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-old-selectors  " class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section><section><h2 id="attr-and-props">Атрибуты и DOM-свойства</h2><p>При чтении HTML, браузер содает DOM-модель. При этом большинство стандартных HTML-атрибутов становятся свойствами соответствующих объектов. HTML-атрибуты и DOM-свойства обычно, но не всегда соответствуют друг другу, нужно понимать, что такое свойство и что такое атрибут, чтобы работать с ними правильно.</p><p>Например, если тег выглядит как <code>&lt;body id="page"&gt;</code>, то у объекта будет свойство <code>body.id</code> со значением <code>"page"</code>.</p><h3>Свойства</h3><p>Для начала посмотрим на несколько частоприменяющихся свойств.</p><table><tbody><tr><th>Свойство</th><th>Описание</th></tr><tr><td><code>hidden</code></td><td>Технически, атрибут hidden работает так же, как <code>style = "display: none"</code>. Возможные значния <code>true</code> или <code>false</code>.</td></tr><tr><td><code>value</code></td><td>Содержит контент input, select, textarea.</td></tr><tr><td><code>href</code></td><td>Содержимое атрибута <code>href</code> ссылки.</td></tr><tr><td><code>alt</code></td><td>Альтернативный текст изображения.</td></tr></tbody></table><div class="cp_embed_wrapper"><iframe id="cp_embed_RZmgpE" src="./Module 7_files/RZmgpE.html" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-props" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h4>innerHTML и textContent</h4><p><code>elem.innerHTML</code> - свойство, позволяет получить содержимое элемента в виде строки. Оно доступно как для чтения так и для записи. Это значит используя <code>innerHTML</code> мы можем добавить что-то внутрь элемента.</p><p>Значение, возвращаемое <code>innerHTML</code> – всегда валидный HTML-код. При записи можно попробовать записать что угодно(в пределах разумного), но браузер исправит ошибки. Далее мы научимся использовать <code>innerHTML</code> для создания новых DOM-узлов.</p><p><code>elem.textContent</code> - свойство, содержит только текст внутри элемента, за вычетом всех тегов. <code>textContent</code> доступен для записи, при чем вне зависимости что будет передано в <code>textContent</code>, данные всегда будут записаны как текст.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_WEBjVV" src="./Module 7_files/WEBjVV.html" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-innerHTML" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h4>classList</h4><p>Объект, содержит методы для работы с классами элемента.</p><table><tbody><tr><th>Метод</th><th>Описание</th></tr><tr><td><code>elem.classList.contains(cls)</code></td><td>возвращает <code>true/false</code>, в зависимости от того, есть ли у элемента класс <code>cls</code></td></tr><tr><td><code>elem.classList.add(cls)</code></td><td>добавляет класс <code>cls</code> в список классов элемента</td></tr><tr><td><code>elem.classList.remove(cls)</code></td><td>удаляет класс <code>cls</code> из списка классов элемента</td></tr><tr><td><code>elem.classList.toggle(cls)</code></td><td>если класса <code>cls</code> нет, добавляет его, если есть - удаляет.</td></tr></tbody></table><div class="cp_embed_wrapper"><iframe id="cp_embed_eEaRME" src="./Module 7_files/eEaRME.html" scrolling="no" frameborder="0" height="500" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-classList" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>Атрибуты</h3><p>Элементам DOM, соответствуют HTML-теги, у которых есть текстовые атрибуты. Конечно, здесь речь именно об узлах-элементах, не о текстовых узлах или комментариях. Доступ к атрибутам осуществляется при помощи стандартных методов. Эти методы работают со значением, которое находится в HTML.</p><table><tbody><tr><th>Синтаксис</th><th>Описание</th></tr><tr><td><code>elem.hasAttribute(name)</code></td><td>Проверяет наличие аттрибута, возвращает <code>true/false</code></td></tr><tr><td><code>elem.getAttribute(name)</code></td><td>получает значение атрибута и возвращает его</td></tr><tr><td><code>elem.setAttribute(name, value)</code></td><td>устанавливает атрибут</td></tr><tr><td><code>elem.removeAttribute(name)</code></td><td>удаляет атрибут</td></tr><tr><td><code>elem.attributes</code></td><td>свойство, возвращает коллекцию всех атрибутов элемента</td></tr></tbody></table><p>В отличие от свойств, атрибуты всегда являются строками, их имя нечувствительно к регистру и они видны в <code>innerHTML</code>.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_zdQzPP" src="./Module 7_files/zdQzPP(1).html" scrolling="no" frameborder="0" height="319" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-attributes" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>data и dataset</h3><p>В HTML5 можно создавать произвольный атрибут и получать значения этого атрибута в JavaScript. Эту возможность используют для того чтобы упростить написание кода, например получать цвет связанный с input из его data-атрибута. Прием использования произвольного атрибута заключается в следующем:</p><ol><li>Создается атрибут <strong>общий</strong> для группы input: к корню слова <strong>date</strong> через дефис дописывают произвольный суффикс (например - "data-color").</li><li>Вновь созданному атрибуту присваивается значение, связанное с данным input (например - "red", "blue" и т.д.)</li><li>В JavaScript обращаемся к псевдомассиву элементов input для получения значения input - <code>elem.value</code></li><li>В JavaScript обращаемся к псевдомассиву элементов input для получения значения атрибута input - <code>elem.dataset.color</code></li></ol></section><section><h2 id="dom-work">Работа с DOM-узлами</h2><p>Используя DOM API мы можем не только выбирать уже существующие, но и создавать новые узлы. После чего помещать их в документ. Узлы так же можно удалять. При написании веб-приложений именно так и составляются интерфейсы, из многих, динамически создающихся компонентов.</p><h3>Создание элемента</h3><p>Одним из способов создания новых DOM-узлов используется метод <code>createElemen</code>. Он создает элемент HTML, по указаному имени тега и возвращает ссылку на него как результат своего выполнения. <code>tagName</code> - строка, указывающая тип создаваемого элемента (тип тега).</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><div class="cp_embed_wrapper"><iframe id="cp_embed_xLvJwV" src="./Module 7_files/xLvJwV.html" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-createElement" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>Добавление элемента</h3><p>Чтобы DOM-узел был показан на странице, его необходимо добавить в документ. Для этого первым делом нужно решить, куда мы будем его добавлять. Допустим, мы решили, что добавлять будем в некий элемент <code>parentElem</code>, для этого есть методы.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token comment">//Добавляет elem в конец дочерних элементов parentElem</span>
parentElem<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span>

<span class="token comment">/*
  Добавляет elem в коллекцию детей parentElem,
  перед элементом nextSibling.

  Для вставки элемента в начало достаточно вторым
  аргументом insertBefore указать null, тогда
  insertBefore сработает как appendChild.
*/</span>
parentElem<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>elem<span class="token punctuation">,</span> nextSibling<span class="token punctuation">)</span>
</code></pre><div class="cp_embed_wrapper"><iframe id="cp_embed_zdgLmN" src="./Module 7_files/zdgLmN(1).html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-append+insert" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p>Если элемент для вставки это существующий узел, то он изымается из своего старого места и ставится на новое. Отсюда вытекает правило - один и тот же узел не может быть одновременно в двух местах.</p><h4>append/prepend, before/after, replaceWith</h4><p>В стандарте появились методы, которые позволяют вставить что угодно и куда угодно. Эти методы ничего не возвращают. Во всех этих методах <code>nodes</code> – DOM-узлы или строки, в любом сочетании и количестве. Причём строки вставляются именно как текстовые узлы.</p><table><tbody><tr><th>Синтаксис</th><th>Описание</th></tr><tr><td><code>node.append(nodes)</code></td><td>добавляет nodes в конец node</td></tr><tr><td><code>node.prepend(nodes)</code></td><td>добавляет nodes в начало node</td></tr><tr><td><code>node.after(nodes)</code></td><td>добавляет nodes после узла node</td></tr><tr><td><code>node.before(nodes)</code></td><td>добавляет nodes перед узлом node</td></tr><tr><td><code>node.replaceWith(nodes)</code></td><td>добавляет nodes вместо node</td></tr></tbody></table><div class="cp_embed_wrapper"><iframe id="cp_embed_VzoEXa" src="./Module 7_files/VzoEXa(1).html" scrolling="no" frameborder="0" height="460" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-append/prepend" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>Удаление узлов</h3><p>Иногда нужно удалить узел. Для этого есть метод <code>elem.remove()</code>, он удаляет <code>elem</code> из <code>document</code>.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_MvNBde" src="./Module 7_files/MvNBde(1).html" scrolling="no" frameborder="0" height="200" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-removeChild" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>Создание узлов с помощью innerHTML</h3><p>Давайте вспомним о свойстве <code>innerHTML</code> и его важной особенности: оно всегда содержит валидный HTML код. Что будет если мы добавим в <code>innerHTML</code> родителя строку в которой будут HTML-теги? Когда браузер встречает в <code>innerHTML</code> строчный контент который содержит набор тегов, он сам превратит их в валидные DOM-узлы.</p><pre class=" language-javascript"><code class=" language-javascript">el<span class="token punctuation">.</span>innerHTML <span class="token operator">+=</span> <span class="token string">'&lt;p&gt;Hello World!&lt;/p&gt;'</span><span class="token punctuation">;</span></code></pre><p>Код выше говорит браузеру пройтись по строке (распарсить ее), проверить на наличие тегов, если нашел таковые то создать DOM-элементы и вставить их в правильном порядке.</p><div class="note"><p>Изменение <code>innerHTML</code> полностью удалит и пересоздаст всех потомков контейнера. В результате мы получаем огромные дополнительные затраты на сериализацию уже существующего контента.</p></div><div class="cp_embed_wrapper"><iframe id="cp_embed_QMeVyj" src="./Module 7_files/QMeVyj(1).html" scrolling="no" frameborder="0" height="450" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-innerHTML-parse" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>insertAdjacentHTML</h3><p>Метод <code>insertAdjacentHTML</code> парсит указанную строку как HTML и добавляет результирующие узлы в указанное место DOM-дерева. Он не делает повторный рендеринг для существующих элементов внутри элемента-родителя на котором используется. Это позволяет избежать дополнительного этапа сериализации, делая его намного быстрее, чем непосредственная манипуляция <code>innerHTML</code>.</p><pre class=" language-javascript"><code class=" language-javascript">element<span class="token punctuation">.</span><span class="token function">insertAdjacentHTML</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>position</code> - позиция относительно элемента и должна быть одной из следующих значений:</p><table><tbody><tr><th>Значение</th><th>Описание</th></tr><tr><td><code>'beforebegin'</code></td><td>перед element</td></tr><tr><td><code>'afterbegin'</code></td><td>внутрь element, в самое начало контента</td></tr><tr><td><code>'beforeend'</code></td><td>внутрь element, в самый конец контента</td></tr><tr><td><code>'afterend'</code></td><td>после element</td></tr></tbody></table><img src="./Module 7_files/insertAdjacent.png" alt="inserAdjacentHTML image"><div class="note"><p><code>beforebegin</code> и <code>afterend</code> работают только в том случае, если узел находится в дереве DOM и имеет родительский элемент.</p></div><div class="cp_embed_wrapper"><iframe id="cp_embed_jLgQyR" src="./Module 7_files/jLgQyR(1).html" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-insertAdjacent" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p>У этого метода есть «близнецы-братья». Синтаксис этих методов, за исключением последнего параметра, полностью совпадает с <code>insertAdjacentHTML</code>. Вместе они образуют «универсальный швейцарский нож» для вставки чего угодно куда угодно.</p><ul><li><code>elem.insertAdjacentElement(position, newElem)</code> - вставляет в произвольное место не HTML-строку, а элемент <code>newElem</code>.</li><li><code>elem.insertAdjacentText(position, text)</code> - создаёт текстовый узел из строки text и вставляет его в указанное место относительно <code>elem</code>.</li></ul><h3>Клонирование узлов</h3><p>Представим что у нас есть узел с текстом, и мы хотим вставить такой же узел в другую часть документа. Мы уже знаем что каждый узел может существовать в document в одном экземпляре. Но узел можно клонировать и работать с этим клоном (точной копией исходного узла).</p><p>Так же мы могли бы создать новый узел и работать с ним, но в ряде случаев гораздо эффективнее – клонировать существующий, а потом изменить текст внутри. В частности, если элемент большой, то клонировать его будет гораздо быстрее, чем пересоздавать.</p><p>Вызов <code>elem.cloneNode(true)</code> создаст «глубокую» копию элемента – вместе с атрибутами, включая подэлементы. Если же вызвать с аргументом <code>false</code>, то копия будет сделана без дочерних элементов.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_JygaNZ" src="./Module 7_files/JygaNZ(1).html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-07-cloneNode" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section><section><h2 id="optimization">Оптимизация работы с DOM</h2><p>Манипуляция DOM-дерева это очень дорогая операция. Необходимо всеми возожными методами стараться минимизировать количество обращений к DOM. Давайте познакомимся с тремя очень важными концепциями при работе c DOM деревом.</p><h3>Restyle</h3><p>Происходит когда изменения произоишли в стилях элемента влияющих на внешний вид, но не на расположение страницы. К примеру <code>opacity</code>, <code>background-color</code>, <code>visibility</code> и <code>outline</code>. Браузер просто отрисовывает его заново, с учётом нового стиля — происходит <code>repaint</code>. Это дорогая операция потому что браузеру необходимо проверить видимость всех остальных узлов в дереве, один или более могут оказаться невидимыми под изменившим внешний вид узлом.</p><h3>Reflow</h3><p>Происходит когда изменения затрагивают содержимое, структуру документа, положение элементов. Идет пересчет позиционирования и размеров всех элементов, что ведет к перерисовке части или всего документа. Изменения размера одного родительского контейнера повлияет на всех его детей и предков. Имеет значительно большее влияние на производительность.</p><h3>Repaint</h3><p>Когда произошли какие-либо изменения в геометрии либо стилях узла, например, изменения цвета фона или размера, части экрана необходимо будет обновить. Это обновление экрана называется <code>repaint</code>.</p><h3>Причины</h3><p>Всегда необходимо думать об оптимизации работы с DOM. Все вышеперечисленные операции блокируют браузер. Страница не могжет выполнять никакие другие операции в то время, когда проиходит <code>repaint</code>, <code>reflow</code> или <code>restyle</code>. Причинами таких изменений обычно являются:</p><ul><li>Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов)</li><li>Изменение содержимого, в т.ч. текста в полях форм</li><li>Расчёт или изменение CSS-свойств</li><li>Добавление, удаление таблиц стилей</li><li>Манипуляции с атрибутом «class»</li><li>Манипуляции с окном браузера — изменения размеров, прокрутка</li><li>Активация псевдо-классов (например :hover)</li></ul><h3>Дополнительные материалы</h3><ul><li><a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing" target="_blank">Avoid Large, Complex Layouts and Layout Thrashing</a></li><li><a href="https://www.sitepoint.com/10-ways-minimize-reflows-improve-performance/" target="_blank">10 Ways to Minimize Reflows and Improve Performance</a></li><li><a href="https://developers.google.com/speed/articles/reflow" target="_blank">Minimizing browser reflow</a></li></ul></section></article><a href="http://fecore.net.ua/javascript/pages/theory/module-07-1.html#main-nav" class="to-page-nav"></a></div></body></html>
<!DOCTYPE html>
<!-- saved from url=(0061)http://fecore.net.ua/javascript/pages/theory/module-09-2.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Module 9</title><link rel="stylesheet" href="./Module 9-2_files/styles.min.css"><script async="" src="./Module 9-2_files/scripts.min.js.Без названия"></script></head><body class="theory-page"><div class="wrapper"><article><header><nav class="table-of-contents" id="main-nav"><ol class="page-nav" id="page-nav"><li><a href="http://fecore.net.ua/javascript/pages/theory/module-09-2.html#entry">Введение</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-09-2.html#initialization">Создание</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-09-2.html#usage">Использование</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-09-2.html#chaining">Цепочки промисов</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-09-2.html#static">Promise.all и Promise.race</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-09-2.html#materials">Дополнительные материалы</a></li></ol></nav></header><section><h2 id="entry">Введение</h2><p><strong>Promise (обещание, промис)</strong> - объект, представляющий текущее состояние асинхронной операции. Удобный способ организации асинхронного кода.</p><p>У промиса есть 2 состояния:</p><ul><li><strong>Pending</strong> - ожидание, исходное состояние при создании промиса</li><li><strong>Settled</strong> - выполнен, которое в свою очередь имеет 2 варианта результата.<ul><li><strong>fullfilled</strong> - выполнено успешно</li><li><strong>rejected</strong> - выполнено с ошибкой</li></ul></li></ul><img src="./Module 9-2_files/promise-intro.png" alt="promise intro"><p>Вначале промис находится в состоянии <strong>ожидания (pending)</strong>, после чего он может выполнится <strong>успешно (fulfilled)</strong> или с <strong>ошибкой (rejected)</strong>. Грубо говоря, промис это болванка для данных, значение которых мы не знаем в момент его создания.</p><p>Когда промис переходит в состояние <strong>выполнен (settled)</strong>, с результатом (resolved) или ошибкой (rejected) – это навсегда.</p><p>Способ использования, в общих чертах, такой:</p><ul><li>Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.</li><li>Внешний код, получив promise, навешивает на него обработчики.</li><li>По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.</li></ul><img src="./Module 9-2_files/promise-states.png" alt="promise states"><p>Отличия промиса и callback-функции:</p><ul><li>Коллбэки это функции, обещания это объекты</li><li>Коллбэки передаются в качестве аргументов, обещания возвращаются</li><li>Коллбэки обрабатывают успешное или неуспешное завершение, обещания ничего не обрабатывают</li><li>Коллбэки могут обрабатывать несколько событий, обещания связаны только с одним событием</li></ul></section><section><h2 id="initialization">Создание</h2><p>Обещание создается как экземпляр класса <code>Promise(fn)</code> с одной функцией в качестве аргумента. Вызов <code>new Promise</code> немедленно исполнит функцию, переданную в качестве аргумента. Цель этой функции состоит в информировании экземпляра (промиса), когда событие, с которым он связан, будет завершено.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> promise <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
<span class="token comment">// Эта функция будет вызвана автоматически</span>

<span class="token comment">// В ней можно делать любые асинхронные операции.</span>
<span class="token comment">// Когда они завершатся — нужно вызвать одно из:</span>
<span class="token comment">// resolve(результат) при успешном выполнении</span>
<span class="token comment">// reject(ошибка) при ошибке</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Параметры передаваемой функции:</p><ul><li><code>resolve(arg)</code> - функция которую необходимо вызвать при успешной операции. Переданный в нее аргумент будет значением выполненного промиса.</li><li><code>reject(arg)</code> - функция которую необходимо вызвать при ошибке. Переданный в нее аргумент будет значением ошибки которое можно будет обработать.</li></ul><img src="./Module 9-2_files/creating-promises.png" alt="creating promises"><p>В переменную <code>promise</code> будет записан объект обещания в состоянии <strong>pending</strong>, а через 2 секунды, после того как будет вызван <code>resolve("success!")</code>, промис перейдет в состояние <strong>resolved</strong>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> promise <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"success!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section><h2 id="usage">Использование</h2><p>После того как промис создан, с ним можно работать используя методы <code>then</code> и <code>catch</code>. Код пишется так, как будто мы размышляем о том, что может произойти если промис выполнится или нет, не думая о временных рамках.</p><h3>then</h3><p><code>promise.then(onResolve, onReject)</code> - позволяет выполнить код в котором можно получить доступ и обработать результат промиса.</p><img src="./Module 9-2_files/then-catch.png" alt="then-catch"><p>В метод <code>then</code> передаются две функции которые будут вызваны когда промис перейдет в состояние <strong>выполнен (settled).</strong></p><ul><li><code>onResolve(arg)</code> - будет вызвана при успешном выполнении промиса, и получит результат промиса как аргумент (то, что передаем в вызов <code>resolve()</code>).</li><li><code>onReject(arg)</code> - будет вызвана при выполнении промиса с ошибкой, и получит ошибку как аргумент (то, что передаем в вызов <code>reject()</code>).</li></ul><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> promise <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// Если все ок, то вызываем resolve и передаем данные</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"Data passed into resolve function :)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Если что-то не так, вызваем reject и передаем ошибку</span>
    <span class="token comment">// reject("Error passed into reject function :(")</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// выполнится мгновенно</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"BEFORE promise.then"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">onResolve</span> <span class="token operator">=</span> data <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"INSIDE promise.then - onResolve"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Data passed into resolve function :)"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> <span class="token function-variable function">onReject</span> <span class="token operator">=</span> error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"INSIDE promise.then - onReject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Error passed into reject function :("</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token comment">// будет вызвана через 2 секунды, если обещание выполнится успешно</span>
  onResolve<span class="token punctuation">,</span>
  <span class="token comment">// будет вызвана через 2 секунды, если обещание выполнится с ошибкой</span>
  onReject
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// выполнится мгновенно</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"AFTER promise.then"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Обычно, <code>onResolve</code> и <code>onReject</code> объявляют как инлайн функции в методе <code>then</code>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> promise <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// Если все ок, то вызываем resolve и передаем данные</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"Data passed into resolve function :)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Если что-то не так, вызваем reject и передаем ошибку</span>
    <span class="token comment">// reject("Error passed into reject function :(")</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// выполнится мгновенно</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"BEFORE promise.then"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token comment">// будет вызвана через 2 секунды, если обещание выполнится успешно</span>
  data <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"INSIDE promise.then - onResolve"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Data passed into resolve function :)"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// будет вызвана через 2 секунды, если обещание выполнится с ошибкой</span>
  error <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"INSIDE promise.then - onReject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Error passed into reject function :("</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// выполнится мгновенно</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"AFTER promise.then"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3>catch</h3><p>Немного дальше мы узнаем о цепочках промисов, а пока научимся обрабатывать ошибки не в <code>onReject</code> внутри <code>then</code>, а в специальном методе. Обрабатывать ошибки очень удобно, используя метод <code>catch</code> только один раз, в конце цепочки.</p><p><code>promise.catch(onReject)</code> - хендлер для обработки состояния <code>reject</code>, исполнится только если промис исполнится с ошибкой (rejected).</p><p><code>onReject(arg)</code> - будет вызвана при выполнении промиса с ошибкой, и получит ошибку как аргумент (то, что передаем в вызов <code>reject()</code>).</p><p>Создадим обещание, сделаем задержку на 2 секунды, вызовем <code>reject</code>, имитируя выполнение промиса с ошибкой.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> promise <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"Info about error!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
* then не выполнится так как в функции fn, внутри new Promise(fn),
* был вызван reject(). А catch как раз выполнится через 2 секунды
*/</span>
promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>error <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Info about error!"</span></code></pre><h3>finally</h3><p>Позволяет выполнить указанную callback-функцю после того как обещание будет разрешено (выполнено или отклонено). Позволяет избежать дублирования кода в обработчиках <code>then()</code> и <code>catch()</code>. Возвращает обещание.</p><pre class=" language-javascript"><code class=" language-javascript">promise<span class="token punctuation">.</span><span class="token keyword keyword-finally">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// settled (fulfilled или rejected)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Этот метод может быть полезен, если вы хотите выполнить некоторую обработку или очистку после того как обещание будет исполнено, независимо от результата.</p><p>Функция обратного вызова не получит никаких аргументов, поскольку нельзя точно определить выполнено ли обещание или отклонено. Тут будет выполняться код который зависит только от времени его исполнения, поэтому значение промиса тут не важно.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> promise <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"success!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "success"</span>
  <span class="token punctuation">.</span><span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword keyword-finally">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'finished!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "finished"</span></code></pre></section><section><h2 id="chaining">Цепочки промисов</h2><p><strong>Чейнинг (chaining)</strong> - возможность строить асинхронные цепочки из промисов. Одна из основных причин существования и активного использования промисов.</p><p>Каждый метод <code>then</code>, результатом своего выполнения, возвращает промис. Его значением будет то, что возвращается из callback-функции <code>onResolve</code>.</p><img src="./Module 9-2_files/chaining.png" alt="chaining"><pre class=" language-javascript"><code class=" language-javascript"><span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
  <span class="token operator">...</span>
  <span class="token punctuation">.</span><span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Так как <code>then</code> возвращает промис, до его выполнения может пройти некоторое время, поэтому оставшаяся часть цепочки будет ждать.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> promise <span class="token operator">=</span> <span class="token keyword keyword-new">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
    <span class="token keyword keyword-return">return</span> value <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>
    <span class="token keyword keyword-return">return</span> value <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>error <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>При возникновении ошибки в любом месте цепочки, выполнение всех последующих <code>then</code> отменяется, а управление передается методу <code>catch</code>.</p></section><section><h2 id="static">Promise.all и Promise.race</h2><p>Иногда бывают ситуации когда нам необходимо дождаться выполнения не одного, а сразу набора промисов, и только тогда что-то сделать. Бывают и такие ситуации когда из набора промисов необходимо дождаться выполнения любого одного, проигнорировав остальные.</p><h3>Promise.all</h3><p><code>Promise.all([promise1, promise2, ...])</code> - статический метод, получает массив промисов и ждет их исполнения, возвращает промис.</p><p>При успешном выполнении всех промисов из массива, промис возвращаемый из <code>Promise.all</code> перейдет в состояние <strong>settled -&gt; fullfilled</strong>, а его значением будет массив результатов исполнения каждого промиса.</p><p>Если в массиве промисов хотябы один исполнился с ошибкой, то перейдет в состояние <strong>settiled -&gt; rejected</strong>, а значением промиса будет ошибка.</p><p>Давайте напишем функцию, которая будет принимать текст для <code>resolve</code>, и задержку в <strong>мс</strong>, а результатом своего выполнения будет возвращать промис. Затем создадим 2 промиса с разным временем задержки.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">makePromise</span> <span class="token operator">=</span> <span class="token punctuation">(</span>text<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword keyword-new">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> promiseA <span class="token operator">=</span> <span class="token function">makePromise</span><span class="token punctuation">(</span><span class="token string">"promiseA"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-const">const</span> promiseB <span class="token operator">=</span> <span class="token function">makePromise</span><span class="token punctuation">(</span><span class="token string">"promiseB"</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// выполнится спустя 3 секунды,</span>
<span class="token comment">// когда выполнится второй промис с задержкой в 3c.</span>
<span class="token comment">// Первый выполнится через секунду и просто будет готов</span>
Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>promiseA<span class="token punctuation">,</span> promiseB<span class="token punctuation">]</span> <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//["promiseA", "promiseB"]</span>
  <span class="token punctuation">.</span><span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3>Promise.race</h3><p><code>Promise.race([promise1, promise2, ...])</code> - статический метод, получает массив промисов и возвращает обещание. Когда хотябы одно обещание в массиве исполнилось, исполнится возвращаемый промис.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> <span class="token function-variable function">makePromise</span> <span class="token operator">=</span> <span class="token punctuation">(</span>text<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token keyword keyword-new">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword keyword-const">const</span> promiseA <span class="token operator">=</span> <span class="token function">makePromise</span><span class="token punctuation">(</span><span class="token string">"promiseA"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword keyword-const">const</span> promiseB <span class="token operator">=</span> <span class="token function">makePromise</span><span class="token punctuation">(</span><span class="token string">"promiseB"</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// выполнится спустя 1 секунду, когда выполнится</span>
<span class="token comment">// самый быстрый promiseA с задержкой в 1c.</span>
<span class="token comment">// Второй промис promiseB будет проигнорирован</span>
Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span> <span class="token punctuation">[</span>promiseA<span class="token punctuation">,</span> promiseB<span class="token punctuation">]</span> <span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>result <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// "promiseA"</span>
  <span class="token punctuation">.</span><span class="token keyword keyword-catch">catch</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></section><section><h2 id="materials">Дополнительные материалы</h2><p>Для дальнейшего изучения промисов ознакомьтесь со статьями по ссылкам.</p><ul><li><a href="https://kosamari.com/notes/the-promise-of-a-burger-party" target="_blank">The Promise of a Burger Party (оригинал)</a></li><li><a href="https://habr.com/company/nixsolutions/blog/323066/" target="_blank">Промисы на примере бургер-вечеринки (перевод, обязательно к прочтению)</a></li><li><a href="http://exploringjs.com/es6/ch_promises.html" target="_blank">Promises for asynchronous programming</a></li><li><a href="https://ourcodeworld.com/articles/read/317/how-to-check-if-a-javascript-promise-has-been-fulfilled-rejected-or-resolved" target="_blank">How to check if a Javascript promise has been fulfilled, rejected or resolved</a></li></ul></section></article><a href="http://fecore.net.ua/javascript/pages/theory/module-09-2.html#main-nav" class="to-page-nav"></a></div></body></html>
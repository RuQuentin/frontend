<!DOCTYPE html>
<!-- saved from url=(0061)http://fecore.net.ua/javascript/pages/theory/module-08-2.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Module 8</title><link rel="stylesheet" href="./Module 8-2_files/styles.min.css"><script async="" src="./Module 8-2_files/ei.js.Без названия"></script><script async="" src="./Module 8-2_files/scripts.min.js.Без названия"></script></head><body class="theory-page"><div class="wrapper"><article><header><nav class="table-of-contents" id="main-nav"><ol class="page-nav" id="page-nav"><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-2.html#mouse">События мыши</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-2.html#keyboard">События клавиатуры</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-2.html#form">События элементов форм</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-2.html#scroll">Событие прокрутки</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-2.html#throttling">Throttling and debouncing</a></li></ol></nav></header><section><h2 id="mouse">События мыши</h2><p>В этой секции мы познакомимся со списком событий мыши, рассмотрим их общие свойства, а также те события, которые связаны с кликом. Можно разделить события на два типа: простые и комплексные.</p><p>Простые:</p><ul><li><code>mousedown</code> - кнопка мыши нажата над элементом.</li><li><code>mouseup</code> - кнопка мыши отпущена над элементом.</li><li><code>mouseover</code> - курсор мыши появился над элементом.</li><li><code>mouseout</code> - курсор мыши ушел с элемента.</li><li><code>mousemove</code> - каждое движение мыши над элементом генерирует это событие.</li></ul><p>Комплексные:</p><ul><li><code>click</code> - Вызывается при клике мышью, то есть при mousedown, а затем mouseup на одном элементе</li><li><code>contextmenu</code> - Вызывается при клике правой кнопкой мыши на элементе.</li><li><code>dblclick</code> - Вызывается при двойном клике по элементу.</li></ul><h3>Порядок срабатывания событий</h3><p>Одно действие может вызывать несколько событий. Например, клик вызывает сначала <code>mousedown</code>, а затем <code>mouseup</code> и <code>click</code>. В тех случаях, когда одно действие генерирует несколько событий, их порядок фиксирован. То есть, обработчики вызовутся в порядке <code>mousedown → mouseup → click</code>.</p><p>Каждое событие обрабатывается независимо. Например, при клике, события mouseup + click возникают одновременно, но обрабатываются последовательно. Сначала полностью завершается обработка mouseup, затем запускается click.</p><h3>Модификаторы клика</h3><p>Во всех событиях мыши присутствует информация о нажатых клавишах-модификаторах: <code>shiftKey</code>, <code>altKey</code>, <code>ctrlKey</code>, <code>metaKey</code>.</p><p>На компьютерах с системой Windows и Linux есть клавиши <strong>Alt</strong>, <strong>Shift</strong> и <strong>Ctrl</strong>. На Mac есть ещё одна специальная клавиша: <strong>Cmd</strong>, которой соответствует свойство <code>metaKey</code>. Чтобы пользователи обоих операционных систем работали с комфортом, в паре с ctrlKey нужно обязательно использовать metaKey.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>ctrlKey <span class="token operator">||</span> event<span class="token punctuation">.</span>metaKey<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span></code></pre><h3>Координаты клика</h3><p>Все события мыши предоставляют текущие координаты курсора в двух видах: относительно окна и относительно документа.</p><p>Свойства <code>clientX/clientY</code> содержат координаты курсора относительно текущего окна. При этом, например, если ваше окно размером 1000x1000, а мышь находится в центре, тогда и <code>clientX</code> и <code>clientY</code> будут равны 500.</p><p>Можно как угодно прокручивать страницу, но если не двигать при этом мышь, то координаты курсора <code>clientX/clientY</code> не изменятся, потому что они считаются относительно окна, а не документа.</p><p>Свойства <code>pageX/pageY</code> содержат координаты курсора относительно документа. Так как эти координаты – относительно левого-верхнего угла документа, а не окна, то они учитывают прокрутку. Если прокрутить страницу, а мышь не трогать, то координаты курсора <code>pageX/pageY</code> изменятся на величину прокрутки, они привязаны к конкретной точке в документе.</p><h3>Движение мыши</h3><h4>mouseover/mouseout, relatedTarget</h4><p>Событие <code>mouseover</code> происходит, когда мышь появляется над элементом, а <code>mouseout</code> – когда уходит из него. При этом мы можем узнать, с какого элемента пришла (или на какой ушла) мышь, используя дополнительное свойство объекта события <code>relatedTarget</code>.</p><p>Например, в обработчике события <code>mouseover</code>:</p><ul><li><code>event.target</code> – элемент, на который пришла мышь, то есть на котором возникло событие.</li><li><code>event.relatedTarget</code> – элемент, с которого пришла мышь.</li></ul><p>Для <code>mouseout</code> всё наоборот:</p><ul><li><code>event.target</code> – элемент, с которого ушла мышь, то есть на котором возникло событие.</li><li><code>event.relatedTarget</code> – элемент, на который перешла мышь.</li></ul><p>Свойство <code>relatedTarget</code> может быть равно <code>null</code>. Это вполне нормально и означает, что мышь пришла не с другого элемента, а из-за пределов окна (или ушла за окно). Всегда необходимо иметь в виду такую возможность при обращении к свойству <code>event.relatedTarget</code>.</p><p>При переходе на потомка срабатывает <code>mouseout</code> на родителе. Согласно браузерной логике, курсор мыши может быть только над одним элементом – самым глубоким в DOM (и верхним по z-index).</p><p>Представьте ситуацию – курсор зашёл на элемент. Сработал <code>mouseover</code> на нём. Потом курсор идёт на дочерний… И, оказывается, на элементе-родителе при этом происходит <code>mouseout</code>! Как будто курсор с него ушёл, хотя он всего лишь перешёл на потомка. Так что если он перешел куда-нибудь, то автоматически ушёл с предыдущего элемента. Всё просто.</p><h4>mouseenter и mouseleave</h4><p>События <code>mouseenter/mouseleave</code> похожи на <code>mouseover/mouseout</code>. Они тоже срабатывают, когда курсор заходит на элемент и уходит с него, но с двумя отличиями.</p><ul><li>Не учитываются переходы внутри элемента.</li><li>Они не всплывают.</li></ul><p>Эти события более интуитивно понятны. Курсор заходит на элемент – срабатывает <code>mouseenter</code>, а затем – неважно, куда он внутри него переходит, <code>mouseleave</code> будет, когда курсор окажется за пределами элемента.</p><p>События <code>mouseenter/leave</code> более наглядны и понятны, но они не всплывают, а значит с ними нельзя использовать делегирование.</p><p>Представте, что нужно обработать вход/выход мыши для ячеек таблицы. В таблице таких ячеек тысяча. Естественное решение – делегирование, поставить обработчик на элемент <strong>table</strong> и ловить все события в нём.</p><p>Но события <code>mouseenter/leave</code> не всплывают, они срабатывают именно на том элементе, на котором стоит обработчик и только на нём. Если обработчики <code>mouseenter/leave</code> стоят на <code>table</code>, то они сработают при входе-выходе из таблицы, и получить из них какую-то информацию о переходах по её ячейкам невозможно. В таких случаях необходимо использовать <code>mouseover/mouseout</code>.</p></section><section><h2 id="keyboard">События клавиатуры</h2><p>Есть всего три события клавиатуры: <code>keyup</code>, <code>keydown</code>, <code>keypress</code>.</p><h3>keydown и keyup</h3><p>Происходят при нажатии/отпускании клавиши и позволяют получить её скан-код в свойстве <code>key</code>. Скан-код клавиши одинаков в любой раскладке и в любом регистре. Например, клавиша <strong>z</strong> может означать символ <strong>"z"</strong>, <strong>"Z"</strong> или <strong>"я"</strong>, <strong>"Я"</strong> в русской раскладке, но её скан-код будет всегда одинаков - <strong>90</strong>.</p><h4>Скан-коды</h4><p>Для буквенно-цифровых клавиш есть очень простое правило: скан-код будет равен коду соответствующей заглавной английской буквы/цифры.</p><p>Например, при нажатии клавиши <code>S</code> (не важно, каков регистр и раскладка) её скан-код будет равен <code>"S".charCodeAt(0)</code>.</p><p>Скан-код хранится в <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key" target="_blank">KeyboardEvent.key</a></p><h3>keypress</h3><p>Возникает сразу после <code>keydown</code>, если нажата символьная клавиша, т.е. нажатие приводит к появлению символа.</p><p>Любые буквы, цифры генерируют <code>keypress</code>. Управляющие клавиши, такие как <strong>Ctrl</strong>, <strong>Shift</strong> не генерируют <code>keypress</code>.</p><p>Позволяет получить код символа. В отличие от скан-кода, он специфичен именно для символа и различен для <strong>"z"</strong> и <strong>"я"</strong>.</p><p>Код символа хранится в <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code" target="_blank">KeyboardEvent.code</a>.</p></section><section><h2 id="form">События элементов форм</h2><p>В этой секции разберёмся со списком событий формы и ее элементов.</p><h3>Формы: отправка, событие и метод submit</h3><p>Событие <code>submit</code> возникает при отправке формы. Наиболее частое его применение – это валидация (проверка) формы перед отправкой. Метод submit позволяет инициировать отправку формы из JavaScript, без участия пользователя.</p><p>Чтобы отправить форму на сервер, у посетителя есть два способа:</p><ul><li>Нажать кнопку с <code>type="submit"</code></li><li>Нажать <strong>Enter</strong>, находясь на каком-нибудь поле формы</li></ul><p>Какой бы способ ни выбрал посетитель – будет сгенерировано событие <code>submit</code>. Обработчик в нём может проверить данные и, если они неверны, то вывести ошибку и сделать <code>event.preventDefault()</code> – тогда форма не отправится на сервер.</p><p>Чтобы отправить форму на сервер из JavaScript – нужно вызвать на элементе формы метод <code>submit()</code>. При этом само событие <code>submit</code> не генерируется. Предполагается, что если программист вызывает метод <code>submit()</code>, то он выполнил все проверки. Это используют, в частности, для искусственной генерации и отправки формы.</p><h3>Фокусировка</h3><p>Элемент «получает фокус», когда посетитель фокусируется на нём. Обычно фокусировка автоматически происходит при нажатии на элементе мышкой, но также можно перейти на нужный элемент клавиатурой – через клавишу <strong>Tab</strong>, нажатие пальцем на планшете.</p><p>Момент получения фокуса и потери очень важен. При получении фокуса мы можем подгрузить данные для автодополнения, начать отслеживать изменения. При потере – проверить данные, которые ввёл посетитель.</p><h4>События focus/blur и focusin/focusout</h4><p>Событие <code>focus</code> вызывается тогда, когда пользователь фокусируется на элементе, а <code>blur</code> – когда фокус исчезает, например посетитель кликает на другом месте экрана.</p><p>У них есть особенности:</p><ul><li>Они не всплывают.</li><li>Поддерживаются всплывающие альтернативы <code>focusin/focusout</code>.</li><li>По умолчанию многие элементы не могут получить фокус. Например, если кликнуть по <code>div</code>, то фокусировка на нем не произойдет.</li><li>Текущий элемент, на котором фокус, доступен как <code>document.activeElement</code>.</li></ul><p>События <code>focusin/focusout</code> – то же самое, что и <code>focus/blur</code>, только они всплывают.</p><h4>Методы focus/blur</h4><p>Методы с теми же названиями переводят/убирают фокус с элемента.</p><h3>События элементов формы</h3><p>На элементах формы происходят события клавиатуры и мыши, но есть и несколько других, особенных событий.</p><h4>Событие change</h4><p>Происходит по окончании изменения значения элемента формы, когда это изменение зафиксировано. Для текстовых элементов событие произойдёт не при каждом вводе, а при потере фокуса. Например, пока вы набираете что-то в текстовом поле ниже - события нет. Но как только вы уведёте фокус на другой элемент, например, нажмёте кнопку - произойдет событие onchange. Для остальных же элементов: <code>select</code>, <code>input</code>, <code>type=checkbox/radio</code> оно срабатывает сразу при выборе значения.</p><h4>Событие input</h4><p>Событие срабатывает только на текстовых элементах. Оно не ждет потери фокуса, в отличие от <code>change</code>.</p><p>Срабатывает тут же при изменении значения текстового элемента, не ждет потери фокуса, в отличие от <code>change</code>. Доступно только на <code>type=text</code>. В современных браузерах <code>input</code> – самое главное событие для работы с элементом формы. Именно его, а не <code>keydown/keypress</code> следует использовать.</p></section><section><h2 id="scroll">Событие прокрутки</h2><p>Событие <code>onscroll</code> происходит, когда элемент прокручивается. Оно генерируется всегда, при любой прокрутке, не обязательно мышью.</p><p>Возможные области применения <code>onscroll</code>:</p><ul><li>Отображение дополнительных элементов навигации при прокрутке.</li><li>Подгрузка и инициализация элементов интерфейса, ставших видимыми после прокрутки.</li></ul><p>Обработчик события ниже будет вызываться при каждом скроле в окне.</p><pre class=" language-javascript"><code class=" language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'scroll'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'scrolling!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Если вы хотите узнать на сколько был проскролен документ относительно своего верхнего левого угла, используйте свойтсва объекта <code>window</code>:</p><ul><li><code>pageXOffset</code> - вернет кол-во пикселей текущей горизонтальной прокрутки документа</li><li><code>pageYOffset</code> - вернет кол-во пикселей текущей вертикальной прокрутки документа</li></ul><p>Давайте будем выводить в консоль кол-во пикселей при вертикальном скроле.</p><pre class=" language-javascript"><code class=" language-javascript">window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'scroll'</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'pageYOffset: '</span><span class="token punctuation">,</span> pageYOffset<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3>Координаты и размер элемента</h3><p>Так как <code>scroll</code> часто используется в связке с изменением поведения элементов, кратко рассмотрим методы получения геометрии и координат элемента.</p><p>Предположим у нас есть произвольный DOM-узел <code>elem</code>, тогда:</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token comment">// Ширина и высота элемента включая рамки (border)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'offsetWidth: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'offsetHeight: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>offsetHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Отступ внутренней части от внешней, рамка + скролл если есть</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'clientTop: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>clientTop<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'clientLeft: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>clientLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Размеры видимой внутренней части элемента</span>
<span class="token comment">// с padding но без scrollbar</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'clientWidth: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>clientWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'clientHeight: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>clientHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Размеры внутренней части элемента включая невидимую часть</span>
<span class="token comment">// со скролом включает падинг и не включает scrollbar</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'scrollWidth: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>scrollWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'scrollHeight: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>scrollHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Размеры прокрученной части элемента от левого верхнего угла</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'scrollLeft: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>scrollLeft<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'scrollTop: '</span><span class="token punctuation">,</span> elem<span class="token punctuation">.</span>scrollTop<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Для того чтобы получить координаты элемента <strong>относительно viewport</strong> используется метод <code>getBoundingClientRect()</code>, который вернет объект содержащий тeкущие координаты элемента относительно <code>vieport</code>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> coords <span class="token operator">=</span> elem<span class="token punctuation">.</span><span class="token function">getBoundingClientRect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><img src="./Module 8-2_files/getBCR.png" alt="phases"><ul><li><code>top</code> – Y-координата верхней границы элемента</li><li><code>left</code> – X-координата левой границы</li><li><code>right</code> – X-координата правой границы</li><li><code>bottom</code> – Y-координата нижней границы</li></ul><p>Координаты относительно окна не учитывают прокрутку, они высчитываются от границ текущей видимой области. Иначе говоря, если страницу прокрутить, то элемент поднимется выше или опустится ниже – его координаты относительно окна изменятся.</p><p>Координаты могут быть дробными – это нормально. Координаты могут быть и отрицательными, например если прокрутить страницу так, что верх элемента будет выходить за верхнуюю границу окна, то его <code>top</code>-координата будет меньше нуля.</p><p><a href="https://youtu.be/MKpZadkuT-0" target="_blank" rel="noopener">getBoundingClientRect() in Javascript DOM</a></p><h3>Практика</h3><p>Разберите пример. В тот момент когда значение прокрутки окна <code>pageYOffset</code> становится больше чем начальная позиция навигации в окне, задаем навигации дополинтельный css-класс, в противном случае убираем. Также зададим <code>body</code> небольшой верхний падинг равный высоте самой навигации для избежания еффекта подпрыгивания контента под <code>nav</code>, из-за того что <code>nav</code> перестает быть в потоке документа.</p><p>В дополнение используем метод <code>window.scrollTo</code> для плавной прокрутки документа до секции с <code>id</code> равным <code>href</code> ссылки меню в которую кликнули. А при нажатии на иконку со стрелкой вверх, прокрутим документ до начальной позиции.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_RyWqNe" src="./Module 8-2_files/RyWqNe.html" scrolling="no" frameborder="0" height="428" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-08-nav-example" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p>Статья с примерами липкой навигации <a href="https://osvaldas.info/auto-hide-sticky-header" target="_blank" rel="noopener">Auto-Hide Sticky Header</a></p></section><section><h2 id="throttling">Throttling and debouncing</h2><ul><li><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank">Debouncing and Throttling Explained Through Examples</a></li><li><a href="https://medium.com/@jh3y/throttling-and-debouncing-in-javascript-b01cad5c8edf" target="_blank">Throttling and Debouncing in JavaScript (medium)</a></li><li><a href="https://codeburst.io/throttling-and-debouncing-in-javascript-646d076d0a44" target="_blank">Throttling and debouncing in JavaScript (codeburst)</a></li></ul></section></article><a href="http://fecore.net.ua/javascript/pages/theory/module-08-2.html#main-nav" class="to-page-nav"></a></div></body></html>
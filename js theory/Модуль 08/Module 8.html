<!DOCTYPE html>
<!-- saved from url=(0061)http://fecore.net.ua/javascript/pages/theory/module-08-1.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>Module 8</title><link rel="stylesheet" href="./Module 8_files/styles.min.css"><script async="" src="./Module 8_files/ei.js.Без названия"></script><script async="" src="./Module 8_files/scripts.min.js.Без названия"></script></head><body class="theory-page"><div class="wrapper"><article><header><nav class="table-of-contents" id="main-nav"><ol class="page-nav" id="page-nav"><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-1.html#basics">События</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-1.html#event">Объект события</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-1.html#bubbling">Всплытие событий</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-1.html#delegation">Делегирование событий</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-1.html#defaults">Действия браузера по умолчанию</a></li><li><a href="http://fecore.net.ua/javascript/pages/theory/module-08-1.html#doc-load">Загрузка документа</a></li></ol></nav></header><section><h2 id="basics">События</h2><p>Для реакции на действия посетителя и внутреннего взаимодействия скриптов существуют события. JavaScript выполняется в едином потоке. Обычно события становятся в очередь и обрабатываются в порядке поступления, асинхронно, независимо друг от друга.</p><p><strong>Событие</strong> – это сигнал от браузера о том, что что-то произошло. Существует много видов событий, рассмотрим некоторые из них в таблице.</p><table><tbody><tr><th>Событие</th><th>Описание</th></tr><tr><td>click</td><td>происходит, когда кликнули на элемент левой кнопкой мыши</td></tr><tr><td>submit</td><td>посетитель отправил форму</td></tr><tr><td>focus</td><td>посетитель фокусируется на элементе, например нажимает на input</td></tr><tr><td>keydown</td><td>когда посетитель нажимает клавишу</td></tr><tr><td>keyup</td><td>когда посетитель отпускает клавишу</td></tr><tr><td>DOMContentLoaded</td><td>когда HTML загружен и обработан, DOM документа полностью построен и доступен</td></tr></tbody></table><h3>Слушатели событий</h3><p>Для того чтобы элемент интерфейса реагировал на дейтсия пользователя, на него необходимо повесить обработчик (слушателя) события, то есть функцию, которая сработает, как только событие произошло. Именно благодаря обработчикам JavaScript-код может реагировать на действия посетителя.</p><p>Методы <code>addEventListener</code> и <code>removeEventListener</code> являются современным способом назначить или удалить обработчик, и при этом позволяют использовать сколько угодно обработчиков.</p><h4>addEventListener</h4><p>Назначение обработчика осуществляется вызовом <code>addEventListener</code> с тремя аргументами.</p><pre class=" language-javascript"><code class=" language-javascript">element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> handler<span class="token punctuation">[</span><span class="token punctuation">,</span> phase<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><table><tbody><tr><th>Аргумент</th><th>Назначение</th></tr><tr><td><code>event</code></td><td>Имя события, например click, передается как строка</td></tr><tr><td><code>handler</code></td><td>Ссылка на функцию, которую надо поставить обработчиком</td></tr><tr><td><code>phase</code></td><td>Необязательный аргумент, «фаза», на которой обработчик должен сработать. Этот аргумент редко нужен.</td></tr></tbody></table><div class="cp_embed_wrapper"><iframe id="cp_embed_ayePLG" src="./Module 8_files/ayePLG.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-08-addListener" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h4>removeEventListener</h4><p>Удаление обработчика осуществляется вызовом <code>removeEventListener</code>. Аргументы те же что у <code>addEventListener</code>.</p><pre class=" language-javascript"><code class=" language-javascript">element<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> handler<span class="token punctuation">[</span><span class="token punctuation">,</span> phase<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><div class="note"><p>Для удаления нужно передать именно ту функцию-обработчик которая была назначена в <code>addEventListener</code>. Поэтому часто для <code>callback</code> используют отдельную функцию и передают ее по имени.</p></div><div class="cp_embed_wrapper"><iframe id="cp_embed_brXOOw" src="./Module 8_files/brXOOw.html" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-08-removeListener" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>this и addEventListener</h3><p>Если мы передаем функцию которая использует <code>this</code>, то по умолчанию <code>this</code> внутри нее будет ссылаться на сам DOM-узел на котором висит <code>addEventListener</code>. Не забывайте привязывать контекст используя <code>bind</code>.</p><pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword keyword-const">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Mango'</span><span class="token punctuation">,</span>
  <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword keyword-this">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// this будет ссылаться на button</span>
    <span class="token comment">// если использовать showName как callback</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`My name is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword keyword-this">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// тут undefined так как поля name нету у button</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Представим что у нас есть кнопка с классом js-btn</span>
<span class="token comment">// Выберем ее и повесим на нее слушатель клика</span>
<span class="token keyword keyword-const">const</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.js-btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

user<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//работает</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span>showName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// не работает</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span>showName<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// работает</span></code></pre><ul><li><a href="http://devdocs.io/dom/eventtarget/addeventlistener" target="_blank">addEventListener</a></li><li><a href="https://learn.javascript.ru/events-and-timing-depth" target="_blank">Порядок исполнения событий</a></li><li><a href="https://learn.javascript.ru/event-details" target="_blank">События в деталях</a></li></ul></section><section><h2 id="event">Объект события</h2><p>Чтобы хорошо обработать событие, недостаточно знать о том, что это – «клик» или «нажатие клавиши». Могут понадобиться детали: координаты курсора, введённый символ и другие, в зависимости от события. Объект события содержит ценную информацию о деталях события. Он автоматически передается первым аргументом в обработчик события.</p><table><caption>Некоторые свойства объекта <code>event</code></caption><tbody><tr><th>Свойство</th><th>Описание</th></tr><tr><td><code>event.type</code></td><td>Тип события, например click</td></tr><tr><td><code>event.currentTarget</code></td><td>Элемент, на котором сработал обработчик. Значение – в точности такое же, как и у <code>this</code>, но бывают ситуации, когда обработчик является методом объекта и его <code>this</code> при помощи <code>bind</code> привязан к этому объекту, тогда мы можем использовать <code>event.currentTarget</code></td></tr><tr><td><code>event.clientX</code> и <code>event.clientY</code></td><td>Координаты курсора в момент клика (относительно окна)</td></tr></tbody></table><div class="cp_embed_wrapper"><iframe id="cp_embed_LjwMva" src="./Module 8_files/LjwMva.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-08-event" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p><a href="http://devdocs.io/dom/event" target="_blank"><strong>Описание event в документации</strong></a></p></section><section><h2 id="bubbling">Всплытие событий</h2><p>Сразу скажем, существуют <strong>3</strong> фазы события:</p><ul><li><strong>capturing phase</strong> - событие начинается на window и тонет до самого глубокого целевого элемента</li><li><strong>target phase</strong> - событие дошло до самого глубокого целевого элемента</li><li><strong>bubbling phase</strong> - событие всплывает от самого глубокого целевого элемента до window</li></ul><img src="./Module 8_files/phases.png" alt="phases"><p>Мы с вами рассмотрим всплытие (bubbling), так как это самая часто используемая фаза. Для ознакомления с остальными фазами и более детальной информации <a href="https://www.kirupa.com/html5/event_capturing_bubbling_javascript.htm" target="_blank">прочитайте эту статью</a> и <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase" target="_blank">документацию на MDN</a>.</p><p><strong>Основной принцип всплытия</strong> - при наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности. Всплывают <strong>почти</strong> все события. Например, событие <code>focus</code> не всплывает.</p><img src="./Module 8_files/bubbling.png" alt="bubbling"><p>Давайте сразу рассмотрим пример, так будет понятнее. Есть 3 вложенных элемента <code>div</code>, с обработчиком на каждом. Всплытие гарантирует, что клик по внутреннему <code>inner-child</code> вызовет обработчик <code>onclick</code> (если есть) сначала на самом <code>inner-child</code>, затем на элементе <code>child</code> далее на элементе <code>parent</code>, и так далее вверх по цепочке родителей до самого <code>document</code>. Поэтому если в примере кликнуть на <code>inner-child</code>, то последовательно выведутся <code>alert: inner-child → child → parent</code>.</p><p>Этот процесс называется <code>всплытием (event bubbling)</code>, потому что события «всплывают» от внутреннего элемента вверх через родителей, подобно тому, как всплывает пузырек воздуха в воде.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_ZJgwWj" src="./Module 8_files/ZJgwWj.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-08-bubbling" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>event.target</h3><p><strong>Целевой элемент (event.target)</strong> - на каком бы элементе мы ни поймали событие, всегда можно узнать где конкретно оно произошло. Самый глубокий элемент, который вызывает событие, называется «целевым» или «исходным» элементом и доступен как <code>event.target</code>.</p><p>Отличия от <code>this (event.currentTarget)</code>:</p><ul><li><code>event.target</code> – это ссылка исходный элемент, на котором произошло событие, в процессе всплытия он неизменен.</li><li><code>this</code> – это текущий элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик. Если callback был стрелочной функцией то <code>this</code> будет другим. В стрелочных функция для получения элемента на котором произошел обработчик используется <code>event.currentTarget</code>.</li></ul><p>Если стоит только один обработчик на самом верхнем элементе, то он «поймает» все клики внутри родителя. Где бы ни был клик внутри – он всплывёт до элемента-родителя, на котором сработает обработчик.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_xLvMLo" src="./Module 8_files/xLvMLo.html" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-08-event-target" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h3>Прекращение всплытия</h3><p>Всплытие идёт прямо наверх. Обычно событие будет всплывать наверх и наверх, до элемента <code>html</code>, а затем до <code>document</code>, а иногда даже до <code>window</code>, вызывая все обработчики на своем пути. Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие. Для остановки всплытия нужно вызвать метод <code>event.stopPropagation()</code>.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_YxmBYq" src="./Module 8_files/YxmBYq.html" scrolling="no" frameborder="0" height="350" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-08-stopProp" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><h4>stopImmediatePropagation</h4><p>Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены. То есть, <code>stopPropagation</code> препятствует продвижению события дальше, но на текущем элементе все обработчики отработают. Для того, чтобы полностью остановить обработку, современные браузеры поддерживают метод <code>event.stopImmediatePropagation()</code>. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.</p><div class="note"><p>Не прекращайте всплытие без необходимости! Всплытие – это удобно. Зачастую прекращение всплытия создаёт свои подводные камни, которые потом приходится обходить.</p></div></section><section><h2 id="delegation">Делегирование событий</h2><p>Всплытие событий позволяет реализовать один из самых важных приёмов разработки – <strong>делегирование событий </strong>. Он заключается в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому – мы ставим один обработчик на их общего предка. Из него можно получить целевой элемент <code>event.target</code>, понять на каком именно потомке произошло событие и обработать его.</p><p><strong>Делегирование (event delegation)</strong> – это средство оптимизации интерфейса. Мы используем один обработчик для схожих действий на однотипных элементах.</p><p>Алгоритм использования:</p><ol><li>Вешаем обработчик на контейнер.</li><li>В обработчике: получаем <code>event.target</code>.</li><li>В обработчике: если <code>event.target</code> или один из его родителей в контейнере ( <code>this</code>) – интересующий нас элемент – обработать его.</li></ol><div class="cp_embed_wrapper"><iframe id="cp_embed_NvQoMy" src="./Module 8_files/NvQoMy.html" scrolling="no" frameborder="0" height="400" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-08-delegation" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div><p>Зачем использовать?</p><ul><li>Упрощает инициализацию и экономит память: не нужно вешать много обработчиков.</li><li>Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.</li><li>Удобство изменений: можно массово добавлять или удалять элементы путём изменения <code>innerHTML</code>.</li></ul><p><a href="https://davidwalsh.name/event-delegate" target="_blank"><strong>How JavaScript Event Delegation Works</strong></a></p></section><section><h2 id="defaults">Действия браузера по умолчанию</h2><p>Многие события автоматически влекут за собой действие браузера. Браузер имеет встроенные действия при ряде событий – переход по ссылке, отправка формы и т.п. Как правило, их можно отменить.</p><p>Например:</p><ul><li>Клик по ссылке инициирует переход на новый URL.</li><li>Нажатие на кнопку «отправить» в форме – отсылку ее на сервер.</li><li>Двойной клик на тексте – инициирует его выделение.</li></ul><p>Основной способ это воспользоваться объектом события. Для отмены действия браузера существует стандартный метод <code>event.preventDefault()</code>.</p><div class="cp_embed_wrapper"><iframe id="cp_embed_YxmgPV" src="./Module 8_files/YxmgPV.html" scrolling="no" frameborder="0" height="300" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" name="CodePen Embed" title="module-08-preventDefault" class="cp_embed_iframe " style="width: 100%; overflow: hidden;"></iframe></div></section><section><h2 id="doc-load">Загрузка документа</h2><p>Когда мы открываем веб-страницу, процесс загрузки HTML-документа, условно, состоит из трёх стадий. Все эти стадии очень важны. На каждую можно повесить обработчик, чтобы совершить действия</p><ul><li><code>DOMContentLoaded</code> – браузер полностью загрузил HTML и построил DOM-дерево.</li><li><code>load</code> – браузер загрузил все ресурсы.</li><li><code>beforeunload/unload</code> – уход со страницы.</li></ul><h3>DOMContentLoaded</h3><p>Событие <code>DOMContentLoaded</code> происходит на <code>document</code>. Означает, что все DOM-элементы разметки уже созданы, можно их искать, вешать обработчики, создавать интерфейс, но при этом, возможно, ещё не догрузились какие-то картинки или стили.</p><p>Если в документе есть теги <code>script</code>, то браузер обязан их выполнить до того, как построит <code>DOM</code>. Поэтому событие <code>DOMContentLoaded</code> ждёт загрузки и выполнения таких скриптов. Исключением являются скрипты с атрибутами <code>async</code> и <code>defer</code>, которые подгружаются асинхронно.</p><p>Внешние файлы стилей никак не влияют на событие <code>DOMContentLoaded</code>.</p><pre class=" language-javascript"><code class=" language-javascript">document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"DOMContentLoaded"</span><span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3>onload</h3><p>Событие <code>onload</code> срабатывает на <code>window</code>, когда загружается вся страница, включая ресурсы на ней – стили, картинки и т.д. Его используют редко, поскольку обычно нет нужды ждать загрузки всех ресурсов.</p><h3>onunload</h3><p>Когда человек уходит со страницы или закрывает окно, на <code>window</code> срабатывает событие <code>unload</code>. В нём можно сделать что-то, не требующее ожидания, например, закрыть вспомогательные popup-окна, но отменить сам переход нельзя. Событие почти не используется, как правило, оно бесполезно – мало что можно сделать, зная, что окно браузера прямо сейчас закроется.</p><h3>onbeforeunload</h3><p><code>window.onbeforeunload</code> – это де-факто стандарт для того, чтобы проверить, сохранил ли посетитель данные, действительно ли он хочет покинуть страницу. Если посетитель инициировал переход на другую страницу или нажал «закрыть окно», то обработчик <code>onbeforeunload</code> может приостановить процесс и спросить подтверждение. Для этого ему нужно вернуть строку, которую браузеры покажут посетителю, спрашивая – нужно ли переходить.</p></section></article><a href="http://fecore.net.ua/javascript/pages/theory/module-08-1.html#main-nav" class="to-page-nav"></a></div></body></html>